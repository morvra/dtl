<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
	<meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="Taskrono" />
    <title>Taskrono</title>
    <script src="https://cdn.tailwindcss.com"></script>
	<link href='./taskrono.ico' rel='icon' type='image/x-icon'/>
    <link href='./taskronoicon.png' rel='shortcut icon'/>
    <link href='./taskronoicon.png' rel='apple-touch-icon'/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
		html, body { overscroll-behavior-y: contain; }
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        
        /* header for desktop */
        @media (min-width: 769px) {
            .header {
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
			.sections-wrapper { padding-bottom: 88px; }
			main { max-width: 980px; margin: 0 auto; }
			.task-row { height: 37px; }
        }
        
        /* Compact header for mobile */
        @media (max-width: 768px) {
            .header {
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .mobile-compact-header .header-content {
                padding: 8px 16px !important;
                flex-direction: row !important;
                align-items: center !important;
            }
            .mobile-compact-header h1 {
                display: none;
            }
			p#current-date { color: #333; font-size: 1rem; }
            .mobile-compact-header .header-stats p:first-child {
                font-size: 0.7rem;
            }
            .mobile-compact-header .header-stats p:last-child {
                font-size: 1.1rem;
            }
            .mobile-nav {
                padding: 0 !important;
            }
            .mobile-nav .tab-link {
                padding: 6px 12px !important;
                font-size: 0.8rem !important;
            }
        }
        
        .tab-link.active { border-color: #3b82f6; background-color:#3b82f6; color:white; }
        .tab-content { display:none; }
        .tab-content.active { display:block; }
        .task-row.focused, .subtask-item.focused { background-color: #fef9c3; }
        .task-card.focused { background-color: #fef9c3; border-color: #eab308; }
        ::-webkit-scrollbar { width:8px; height:0px; }
        ::-webkit-scrollbar-track { background:#f1f1f1; border-radius:10px; }
        ::-webkit-scrollbar-thumb { background:#888; border-radius:10px; }
        ::-webkit-scrollbar-thumb:hover { background:#555; }

        .timer-btn {
			min-width: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }
        .task-table th, .task-table td {
             padding-top: 0.25rem;
             padding-bottom: 0.1rem;
             padding-left: 0.5rem;
             padding-right: 0.5rem;
        }

		/* 新しいフローティングバーの基本スタイル */
		#floating-task-bar {
		    display: none;
		    align-items: center;
		    justify-content: space-between;
		    position: absolute;
		    left: 0;
		    right: 0;
		    top: 0;
		    will-change: transform;
		    transition: transform 80ms linear, opacity 0.25s ease-in-out;
		}

		#floating-task-bar.active {
		    display: flex; /* 表示 */
		}

        /* フローティングバー内の左右のボタン共通スタイル */
        .floating-bar-btn {
            height: 56px;
            width: 56px;
            min-width: 56px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: all 0.15s;
        }
        .floating-bar-btn:active {
            transform: scale(0.95);
        }
		
		.fab {
            height: 56px;
            width: 56px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;f
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.2s ease-in-out;
        }
        .fab:hover {
			background-color: #ddd;
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

		/* 同期ボタンコンテナのスタイル */
		#sync-button-floating-container {
		    position: absolute;
		    left: 16px;
		    top: 0;
		    z-index: 40;
		    will-change: transform;
		    transition: transform 80ms linear, opacity 0.3s ease-in-out;
		}

        /* タスク追加ボタンコンテナのスタイル (スマホでは非表示) */
        #add-task-floating-container {
            display: none;
            position: fixed;
            z-index: 40;
        }
        
        /* PC表示用の調整 (画面幅が769px以上の場合) */
        @media (min-width: 769px) {
            #sync-button-floating-container {
				position: fixed;
		        transform: none !important;
				top: auto;
                bottom: 24px;
                left: 24px;
            }

            #add-task-floating-container {
                display: block;
                bottom: 24px;
                right: 24px;
            }
        }
		.small-btn { min-height:44px; min-width:44px; display:inline-flex; align-items:center; justify-content:center; }
        .inline-input, .inline-select { width:100%; box-sizing:border-box; padding:6px 8px; border-radius:6px; border:1px solid #d1d5db; }
        .small-btn { padding:6px 8px; border-radius:6px; font-size:0.9rem; }

        .modal { display:none; position:fixed; z-index:1000; left:0; top:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); }
        .modal.active { display:flex; align-items:center; justify-content:center; }
        .modal-content { background:white; border-radius:8px; max-width:90vw; max-height:90vh; overflow-y:auto; }
		
		.tooltip-container { position: relative; display: inline-block; vertical-align: middle; }
		.custom-tooltip { visibility: hidden; opacity: 0; background-color: #2d3748; color: #fff; text-align: left; border-radius: 6px; padding: 8px 12px; position: absolute; z-index: 10; bottom: 150%; left: 50%; transform: translateX(-50%); transition: opacity 0.1s, visibility 0.1s; width: max-content; max-width: 300px; font-size: 0.875rem; font-weight: normal; line-height: 1.4; white-space: pre-wrap; box-shadow: 0 4px 6px rgba(0,0,0,0.1); pointer-events: none; }
		
		.dragging .custom-tooltip { position: static; transform: none; }
		.custom-tooltip::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #2d3748 transparent transparent transparent; }
        
        .tooltip-container:hover .custom-tooltip { 
            visibility: visible; 
            opacity: 1; 
            transition-delay: 0.1s; 
        }
        .tooltip-container:hover .custom-tooltip.tooltip-top { 
            bottom: 150%; 
            top: auto; 
        }
        .tooltip-container:hover .custom-tooltip.tooltip-bottom { 
            top: 150%; 
            bottom: auto; 
        }
        .custom-tooltip.tooltip-bottom::after { 
            top: -10px; 
            bottom: auto; 
            border-color: transparent transparent #2d3748 transparent; 
        }

        .dragging { opacity: 0.5; background-color: #fef9c3; transform: translate(0, 0); }
		.dragging .custom-tooltip,
		.dragging .tooltip-container:hover .custom-tooltip {
		    visibility: hidden !important;
		    opacity: 0 !important;
		    display: none !important;
		}
        .drag-over { background-color: #e0f2fe; }

		/* ドロップターゲットの表示/非表示制御 */
		.empty-section-drop-target {
		    display: none;
		}
		
		.dragging-active .empty-section-drop-target {
		    display: table-row;
		}
		
		/* テーブル内の空セクション用 */
		.empty-section-drop-target td {
		    padding: 0;
		    border-width: 0;
			line-height: 0;
		}
		
		.dragging-active .empty-section-drop-target td {
		    padding: 0.5rem 1rem !important;
			line-height: 1rem;
		}
		
		/* モバイル表示用 */
		@media (max-width: 768px) {
		    .empty-section-drop-target {
                display: none;
		    }
		    .dragging-active .empty-section-drop-target {
                display: block; /* table-rowではなくblock */
		        height: auto;
		        padding: 1rem !important;
		        margin-top: 0.5rem !important;
		        margin-bottom: 0.5rem !important;
		        border-width: 2px !important;
		    }
		}
		
		.drag-handle { cursor: move; color: #9ca3af; }
        .drag-handle:hover { color: #6b7280; }

        .archive-tabs { border-bottom: 1px solid #e5e7eb; }
        .archive-tab { padding: 8px 16px; cursor: pointer; border-bottom: 2px solid transparent; }
        .archive-tab.active { border-bottom-color: #3b82f6; background-color: #eff6ff; }
        .archive-tab:hover { background-color: #f3f4f6; }

        .time-input { width: 80px; text-align: center; border: 1px solid #d1d5db; border-radius: 4px; padding: 2px 4px; }

		.archive-search-box { display:flex; gap:8px; align-items:center; margin-bottom:12px; }
        .archive-search-input { flex:1; padding:8px 10px; max-width: 50%; border-radius:6px; border:1px solid #d1d5db; background:white; }
        .archive-search-btn { padding:8px 12px; border-radius:6px; background:#3b82f6; color:white; border:none; cursor:pointer; }
        .archive-clear-btn { padding:8px 10px; border-radius:6px; background:#e5e7eb; color:#374151; border:none; cursor:pointer; }
        .search-result-meta { font-size:0.85rem; color:#6b7280; }

        @media (max-width: 768px) {
            .tab-content.active { padding-bottom:160px; }
            .task-card-wrapper {
                space-y: 0.5rem; 
            }
            .task-card {
                border-radius: 0;
            }
            .task-card.completed {
                background-color: #e5e7eb; 
            }
            
            .archive-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .archive-table-wrapper > table {
                min-width: 640px; 
            }
            .archive-table-wrapper td, .archive-table-wrapper th {
                white-space: nowrap; 
            }
            .archive-table-wrapper .task-memo-cell {
                white-space: normal;
                min-width: 250px;
            }
        }
		/* サブタスク */
		.subtask-toggle-icon {
		    cursor: pointer;
		    display: inline-flex;
		    align-items: center;
		    gap: 2px;
		    font-size: 0.75rem;
		    color: #9ca3af;
		    padding: 0px 4px 2px;
		}
		.subtask-toggle-icon:hover {
		    color: #4b5563;
		}
		.subtask-container {
		    display: none; /* 初期状態は非表示 */
		    padding-left: 3.5rem; /* PC表示でのインデント */
		    background-color: #f9fafb;
		}
		.task-row.dragging + .subtask-container-row {
		    display: none;
		}
		.subtask-container-row td {
		    padding: 0;
		}
		.subtask-container.open {
		    display: block; /* 表示状態 */
		}
		.subtask-item {
		    display: flex;
		    align-items: center;
		    padding: 0.3rem 0.5rem;
		    border-bottom: 1px solid #f3f4f6;
		}
		.subtask-item:last-child {
		    border-bottom: none;
		}
		.subtask-item.completed span {
		    text-decoration: line-through;
		    color: #9ca3af;
		}
		.subtask-item .drag-handle {
		    margin-right: 0.5rem;
		}
		
		/* スマホ表示用の調整 */
		@media (max-width: 768px) {
		    .subtask-container {
		        padding-left: 0rem;
		        margin-left: .75rem;
				margin-top: 2px;
				box-shadow: 0px 3px 4px #ccc;
		    }
		}
		
		/* 編集モーダル内のサブタスクスタイル */
		#edit-task-subtasks, #edit-repeat-subtasks { max-height: 200px; overflow-y: auto; }
		.subtask-edit-item {
		    display: flex;
		    align-items: center;
		    gap: 0.5rem;
		    padding: 0.5rem;
		    background-color: #f9fafb;
		    border-radius: 6px;
		}
    </style>
	<script async defer src="https://apis.google.com/js/api.js"></script>
	<script async defer src="https://accounts.google.com/gsi/client"></script>
</head>
<body class="antialiased text-gray-800">

<div class="header">
    <div class="container mx-auto">
		<header class="mobile-compact-header bg-white p-4 pb-1 flex flex-col md:flex-row justify-between items-center header-content">
            <div class="flex-1">
                <h1 class="text-xl font-bold text-gray-700">Taskrono</h1>
                <p id="current-date" class="text-sm text-gray-500"></p>
            </div>
            <div class="flex items-center">
                <div class="mt-2 md:mt-0 text-center md:text-right header-stats">
                    <p class="text-gray-600">全体の終了予測</p>
                    <p id="total-estimated-end-time" class="text-2xl font-semibold text-blue-600">--:--</p>
                </div>
            </div>
        </header>

        <nav class="mobile-nav flex space-x-0 overflow-x-auto">
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="today">当日のタスク</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="repeat">リピートタスク</button>
			<button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="sections">セクション</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="projects">プロジェクト</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="archive">アーカイブ</button>
			<button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" onclick="location.href='./analysis'">分析</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="data">データ管理</button>
        </nav>
    </div>
</div>

<div class="container mx-auto p-4 max-w-7xl">

    <main>
        <div id="today" class="tab-content space-y-4">
            <div class="flex justify-between items-center">
				
				<div id="today-date-nav" class="flex items-center gap-2">
				    <button id="prev-day-btn" class="px-2 py-1.5 rounded-md bg-white hover:bg-gray-100 shadow-sm">&lt;</button>
				    <h2 id="view-date-display" class="font-bold text-lg"></h2>
				    <button id="next-day-btn" class="px-2 py-1.5 rounded-md bg-white hover:bg-gray-100 shadow-sm">&gt;</button>
				    <button id="load-gcal-events-btn" class="p-2 rounded-md bg-white hover:bg-gray-100 shadow-sm hidden" title="Googleカレンダーから予定を読み込む">
					    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
					        <path stroke-linecap="round" stroke-linejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
					    </svg>
					</button>
				</div>
                <p class="text-sm text-gray-500 hidden md:block">[↑][↓]選択, [Space]開始/停止, [P]先送り, [Ctrl+↑][↓]移動, [N]新規, [E]編集, [M]メモ, [D]削除</p>
            </div>
            <div id="sections-container" class="sections-wrapper"></div>
        </div>

        <div id="repeat" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">リピートタスク管理</h2>

                <div class="p-4 border rounded-lg bg-gray-50 space-y-4 mb-6">
                    <div class="space-y-3">
						<h3 class="text-md font-semibold text-gray-700">新規リピートタスク</h3>
                        <div class="flex gap-3">
                            <input type="text" id="repeat-task-name" placeholder="タスク名" class="flex-grow min-w-0 p-2 border rounded-lg bg-white" autocomplete="one-time-code" data-form-type="other" data-lpignore="true">
                            <input type="number" id="repeat-task-time" placeholder="見積(分)" class="w-28 p-2 border rounded-lg bg-white">
                        </div>
                        <div class="flex gap-3">
                            <select id="repeat-task-project" class="flex-grow min-w-0 p-2 border rounded-lg bg-white"></select>
                            <select id="repeat-task-section" class="flex-grow min-w-0 p-2 border rounded-lg bg-white"></select>
                        </div>
                    </div>

                    <div class="space-y-3">
                        <select id="repeat-task-type" class="w-full p-2 border rounded-lg bg-white">
                            <option value="daily">毎日</option>
                            <option value="weekly">毎週</option>
                            <option value="monthly">毎月</option>
                            <option value="yearly">毎年</option>
                            <option value="interval">○日ごと</option>
                        </select>
                        
                        <div id="repeat-weekly-options" class="hidden items-center flex-wrap gap-x-4 gap-y-2 p-3 bg-white rounded-lg border">
                            <div id="repeat-weekly-days" class="flex flex-wrap gap-x-4 gap-y-2 w-full"></div>
                            <div class="w-full border-t my-2"></div>
                            <div class="flex items-center gap-x-4">
                                 <label class="text-sm">間隔: <input type="number" id="repeat-weekly-interval" value="1" class="p-2 border rounded-lg w-20" min="1"> 週ごと</label>
                                 <label class="text-sm">基準日: <input type="date" id="repeat-weekly-start-date" class="p-2 border rounded-lg"></label>
                            </div>
                        </div>
                        <div id="repeat-monthly-options" class="hidden p-3 bg-white rounded-lg border space-y-3">
                            <div class="flex items-center gap-4">
                                <label class="inline-flex items-center"><input type="radio" name="repeat-monthly-type" value="day" checked class="form-radio"><span class="ml-2 text-sm">日付指定</span></label>
                                <label class="inline-flex items-center"><input type="radio" name="repeat-monthly-type" value="weekday" class="form-radio"><span class="ml-2 text-sm">曜日指定</span></label>
                            </div>
                            <div id="repeat-monthly-day-options">
                                <label class="text-sm">日付: <input type="number" id="repeat-monthly-day" placeholder="1～31" class="p-2 border rounded-lg w-24" min="1" max="31"></label>
                            </div>
                            <div id="repeat-monthly-weekday-options" class="hidden items-center gap-2">
                                <select id="repeat-monthly-week" class="p-2 border rounded-lg bg-white">
                                    <option value="1">第1</option><option value="2">第2</option><option value="3">第3</option><option value="4">第4</option><option value="5">最終</option>
                                </select>
                                <select id="repeat-monthly-weekday" class="p-2 border rounded-lg bg-white">
                                    <option value="0">日曜日</option><option value="1">月曜日</option><option value="2">火曜日</option><option value="3">水曜日</option><option value="4">木曜日</option><option value="5">金曜日</option><option value="6">土曜日</option>
                                </select>
                            </div>
                        </div>
                        <div id="repeat-yearly-options" class="hidden p-3 bg-white rounded-lg border">
                            <label class="text-sm">日付:
                                <input type="number" id="repeat-yearly-month" placeholder="月" class="p-2 border rounded-lg w-20" min="1" max="12"> 月
                                <input type="number" id="repeat-yearly-day" placeholder="日" class="p-2 border rounded-lg w-20" min="1" max="31"> 日
                            </label>
                        </div>
                        <div id="repeat-interval-options" class="hidden p-3 bg-white rounded-lg border space-y-2 md:space-y-0 md:items-center md:space-x-4">
                            <label class="text-sm">何日ごと: <input type="number" id="repeat-interval-days" placeholder="例: 3" class="p-2 border rounded-lg w-24" min="1"></label>
                            <label class="text-sm">基準日: <input type="date" id="repeat-interval-start-date" class="p-2 border rounded-lg"></label>
                        </div>
                    </div>
                </div>

                <div class="flex gap-3">
                    <button id="add-repeat-task-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">＋ リピートタスクを追加</button>
                    <button id="generate-from-repeat-btn" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">▶ 今日のタスクを生成</button>
                </div>

                <div id="repeat-tasks-container" class="mt-6"></div>
            </div>
        </div>

		<div id="sections" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">セクション管理</h2>
                <div class="flex flex-wrap gap-4 items-center mb-6 border-b pb-6">
                    <input type="text" id="section-name" placeholder="セクション名 (例: 午前)" class="flex-grow p-2 border rounded-lg">
                    <div class="flex items-center gap-2">
                        <label for="section-time" class="text-sm">開始時刻:</label>
                        <input type="time" id="section-time" value="09:00" class="p-2 border rounded-lg">
                    </div>
                    <button id="add-section-btn" class="bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">＋ セクションを追加</button>
                </div>
                <div id="sections-container-list" class="mt-4">
                    </div>
            </div>
        </div>

        <div id="projects" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">プロジェクト管理</h2>
                <div class="flex flex-wrap gap-4 items-center mb-4">
                    <input type="text" id="project-name" placeholder="プロジェクト名" class="flex-grow p-2 border rounded-lg">
                    <input type="color" id="project-color" value="#4a90e2" class="p-1 h-10 w-12 border rounded-lg">
                    <button id="add-project-btn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">＋ プロジェクトを追加</button>
                </div>
                <div id="projects-container" class="mt-6"></div>
            </div>
        </div>
        
        <div id="archive" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <div class="archive-tabs flex mb-4">
                    <div class="archive-tab active" data-view="date">日付</div>
					<div class="archive-tab" data-view="search">検索</div>
                </div>
                
                <div id="archive-date-view">
                    <div class="flex justify-between items-center mb-4">
                        <button id="prev-archive-day" class="p-2 rounded-md bg-gray-200 hover:bg-gray-300">&lt;</button>
                        <div class="flex items-center gap-2">
                            <h2 id="archive-date" class="font-bold"></h2>
                            <button id="return-to-today-archive" class="p-2 rounded-md bg-white hover:bg-gray-100 shadow-sm border hidden" title="昨日に戻る">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                                </svg>
                            </button>
                        </div>
                        <button id="next-archive-day" class="p-2 rounded-md bg-gray-200 hover:bg-gray-300">&gt;</button>
                    </div>
                    <div id="archive-tasks-list"></div>
                </div>

				<div id="archive-search-view" class="hidden">
    				<div class="archive-search-box">
        				<input id="archive-search-input" class="archive-search-input" type="text" placeholder="タスク名またはメモを検索">
        				<button id="archive-search-btn" class="archive-search-btn">検索</button>
        				<button id="archive-clear-btn" class="archive-clear-btn">クリア</button>
    				</div>
    				<div id="archive-search-results"></div>
				</div>
				
            </div>
        </div>
		
        <div id="data" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">データ管理</h2>
                <div class="space-y-6">
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">Dropbox</h3>
                        <p class="text-sm text-gray-600 mb-3">タスクデータをDropboxに保存し、他のデバイスと同期します。</p>
                        <div id="auth-container">
                            <button id="authorize_button" class="bg-blue-700 hover:bg-blue-800 text-white font-bold py-2 px-4 rounded-lg">Dropbox ログイン</button>
                        </div>
                        <div id="signout_container" class="hidden">
                            <p id="auth-status" class="text-sm text-green-600 mb-2"></p>
                            <button id="signout_button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">ログアウト</button>
                        </div>
                        <p id="drive-status" class="text-sm text-gray-500 mt-2"></p>
                    </div>
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">Googleカレンダー連携</h3>
							<div class="bg-yellow-50 border-l-4 border-yellow-400 text-yellow-700 p-3 rounded-md mb-3 text-sm" role="alert">
							    <p class="font-bold">【開発者向け機能】</p>
							    <p>この連携機能は開発者向けのものです。第三者の方はご利用になれませんのでご了承ください。</p>
							</div>
							<p class="text-sm text-gray-600 mb-3">Googleカレンダーから予定を読み込み、タスクとして自動追加します。</p>
                        <div id="gcal-auth-container">
                            <button id="gcal_authorize_button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Google ログイン</button>
                        </div>
                        <div id="gcal-signout-container" class="hidden">
                            <p id="gcal-auth-status" class="text-sm text-green-600 mb-2"></p>
                            <div class="mb-3">
                                <h4 class="text-md font-semibold mb-2">読み込むカレンダー</h4>
                                <div id="gcal-calendars-list" class="max-h-40 overflow-y-auto space-y-1 p-2 border rounded-md bg-gray-50">
                                    </div>
                            </div>
                            <button id="gcal_signout_button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">ログアウト</button>
                        </div>
                        <p id="gcal-status" class="text-sm text-gray-500 mt-2"></p>
                    </div>
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">データエクスポート</h3>
                        <p class="text-sm text-gray-600 mb-3">現在のデータをJSONファイルとしてダウンロードします。</p>
                        <button id="export-data-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">データをエクスポート</button>
                    </div>
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">データインポート</h3>
                        <p class="text-sm text-gray-600 mb-3">JSONファイルからデータを復元します。IDが重複するデータは上書きされ、存在しないデータは追加されます。</p>
                        <input type="file" id="import-file" accept=".json" class="mb-3 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                        <button id="import-data-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">データをインポート</button>
                    </div>
                    <div class="border p-4 rounded-lg border-red-200">
                        <h3 class="text-lg font-semibold mb-3 text-red-700">データ削除</h3>
                        <p class="text-sm text-gray-600 mb-3">全てのデータを削除します。この操作は元に戻せません。</p>
                        <button id="clear-data-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">全データを削除</button>
                    </div>
                </div>
            </div>
        </div>
    </main>
</div>

<div id="sync-button-floating-container"></div>
<div id="add-task-floating-container"></div>

<div id="floating-task-bar" class="bg-white shadow-[0_-2px_10px_rgba(0,0,0,0.1)] h-20 px-4 z-50">
    <div id="floating-task-bar-content" class="flex items-center justify-between w-full h-full"></div>
</div>

<div id="add-task-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">タスクを追加</h3>
        <div class="space-y-4">
            <input type="text" id="new-task-name" placeholder="タスク名" class="w-full p-2 border rounded-lg" autocomplete="one-time-code" data-form-type="other" data-lpignore="true" >
            <input type="number" id="new-task-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg" value="5">
            <select id="new-task-project" class="w-full p-2 border rounded-lg bg-white"></select>
			<select id="new-task-section" class="w-full p-2 border rounded-lg bg-white"></select>
        </div>
        <div class="flex gap-3 mt-6">
            <button id="save-new-task-btn" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">追加</button>
            <button id="cancel-add-task-btn" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>


<div id="task-edit-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">タスクを編集</h3>
        <div class="space-y-4">
            <input type="text" id="edit-task-name" placeholder="タスク名" class="w-full p-2 border rounded-lg" autocomplete="one-time-code" data-form-type="other" data-lpignore="true">
            <div class="grid grid-cols-2 gap-4">
                 <input type="number" id="edit-task-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg">
                 <select id="edit-task-project" class="w-full p-2 border rounded-lg bg-white"></select>
            </div>
			<div>
	            <label for="edit-task-section" class="text-sm font-medium text-gray-700">セクション</label>
	            <select id="edit-task-section" class="w-full p-2 border rounded-lg bg-white mt-1"></select>
	        </div>
            <textarea id="edit-task-memo" placeholder="メモ" class="w-full p-2 border rounded-lg" rows="1"></textarea>
			
            <div class="mt-2">
                <div class="flex items-center justify-between">
                    <label class="text-sm font-medium text-gray-700">サブタスク</label>
                    <label class="inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="task-subtask-toggle" class="sr-only peer">
                        <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    </label>
                </div>
                <div id="task-subtask-content" class="hidden mt-2">
                    <div id="edit-task-subtasks" class="space-y-2 p-2 border rounded-lg bg-gray-50"></div>
                    <div class="flex gap-2 mt-2">
                        <input type="text" id="new-subtask-name" placeholder="新しいサブタスク名" class="flex-1 p-2 border rounded-lg" autocomplete="one-time-code" data-form-type="other" data-lpignore="true">
                        <button id="add-subtask-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg">追加</button>
                    </div>
                </div>
            </div>
			
            <div class="grid grid-cols-2 gap-4">
                 <div>
                    <label for="edit-task-startTime" class="text-sm font-medium text-gray-700">開始時刻</label>
                    <input type="time" id="edit-task-startTime" class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label for="edit-task-endTime" class="text-sm font-medium text-gray-700">終了時刻</label>
                    <input type="time" id="edit-task-endTime" class="w-full p-2 border rounded-lg">
                </div>
            </div>
        </div>
        <div class="flex gap-3 mt-6">
            <button id="save-task-edit" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">保存</button>
            <button id="cancel-task-edit" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
            <button id="create-repeat-from-task" class="flex-1 bg-green-500 hover:bg-green-600 text-white py-2 px-2 rounded-lg">リピート作成</button>
        </div>
    </div>
</div>

<div id="memo-edit-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">メモを編集</h3>
        <textarea id="edit-memo-text" placeholder="メモを入力..." class="w-full p-2 border rounded-lg h-32"></textarea>
        <div class="flex gap-3 mt-6">
            <button id="save-memo-edit" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">保存</button>
            <button id="cancel-memo-edit" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="repeat-edit-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-lg">
        <h3 class="text-lg font-bold mb-4">リピートタスクを編集</h3>
        <div class="space-y-4">
            <input type="text" id="edit-repeat-name" placeholder="タスク名" class="w-full p-2 border rounded-lg" autocomplete="one-time-code" data-form-type="other" data-lpignore="true">
             <div class="grid grid-cols-2 gap-4">
                <input type="number" id="edit-repeat-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg">
                <select id="edit-repeat-project" class="w-full p-2 border rounded-lg bg-white"></select>
            </div>
	        <div>
	            <label for="edit-repeat-section" class="text-sm font-medium text-gray-700">セクション</label>
	            <select id="edit-repeat-section" class="w-full p-2 border rounded-lg bg-white mt-1"></select>
	        </div>
            <textarea id="edit-repeat-memo" placeholder="メモ" class="w-full p-2 border rounded-lg" rows="1"></textarea>
			
            <div class="mt-2">
                <div class="flex items-center justify-between">
                    <label class="text-sm font-medium text-gray-700">サブタスク</label>
                    <label class="inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="repeat-subtask-toggle" class="sr-only peer">
                        <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    </label>
                </div>
                <div id="repeat-subtask-content" class="hidden mt-2">
                    <div id="edit-repeat-subtasks" class="space-y-2 mt-1 p-2 border rounded-lg bg-gray-50"></div>
                    <div class="flex gap-2 mt-2">
                        <input type="text" id="new-repeat-subtask-name" placeholder="新しいサブタスク名" class="flex-1 p-2 border rounded-lg" autocomplete="one-time-code" data-form-type="other" data-lpignore="true">
                        <button id="add-repeat-subtask-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg">追加</button>
                    </div>
                </div>
            </div>
			
            <select id="edit-repeat-type" class="w-full p-2 border rounded-lg bg-white">
                <option value="daily">毎日</option>
                <option value="weekly">毎週</option>
                <option value="monthly">毎月</option>
                <option value="yearly">毎年</option>
                <option value="interval">○日ごと</option>
            </select>
        </div>

        <div id="edit-repeat-weekly-options" class="hidden items-center flex-wrap gap-x-4 gap-y-2 mt-4 p-3 bg-gray-50 rounded-lg">
             <div id="edit-repeat-weekly-days" class="flex flex-wrap gap-x-4 gap-y-2 w-full"></div>
             <div class="w-full border-t my-2"></div>
             <div class="flex items-center gap-x-4">
                <label class="text-sm">間隔: <input type="number" id="edit-repeat-weekly-interval" value="1" class="p-2 border rounded-lg w-20" min="1"> 週ごと</label>
                <label class="text-sm">基準日: <input type="date" id="edit-repeat-weekly-start-date" class="p-2 border rounded-lg"></label>
             </div>
        </div>
        <div id="edit-repeat-monthly-options" class="hidden mt-4 p-3 bg-gray-50 rounded-lg space-y-3">
             <div class="flex items-center gap-4">
                <label class="inline-flex items-center"><input type="radio" name="edit-monthly-type" value="day" checked class="form-radio"><span class="ml-2 text-sm">日付指定</span></label>
                <label class="inline-flex items-center"><input type="radio" name="edit-monthly-type" value="weekday" class="form-radio"><span class="ml-2 text-sm">曜日指定</span></label>
            </div>
            <div id="edit-repeat-monthly-day-options">
                <label class="text-sm">日付: <input type="number" id="edit-repeat-monthly-day" placeholder="1～31" class="p-2 border rounded-lg w-24" min="1" max="31"></label>
            </div>
            <div id="edit-repeat-monthly-weekday-options" class="hidden items-center gap-2">
                <select id="edit-monthly-week" class="p-2 border rounded-lg bg-white">
                    <option value="1">第1</option><option value="2">第2</option><option value="3">第3</option><option value="4">第4</option><option value="5">最終</option>
                </select>
                <select id="edit-monthly-weekday" class="p-2 border rounded-lg bg-white">
                    <option value="0">日曜日</option><option value="1">月曜日</option><option value="2">火曜日</option><option value="3">水曜日</option><option value="4">木曜日</option><option value="5">金曜日</option><option value="6">土曜日</option>
                </select>
            </div>
        </div>
         <div id="edit-repeat-yearly-options" class="hidden mt-4 p-3 bg-gray-50 rounded-lg">
            <label class="text-sm">日付:
                <input type="number" id="edit-yearly-month" placeholder="月" class="p-2 border rounded-lg w-20" min="1" max="12"> 月
                <input type="number" id="edit-yearly-day" placeholder="日" class="p-2 border rounded-lg w-20" min="1" max="31"> 日
            </label>
        </div>
        <div id="edit-repeat-interval-options" class="hidden mt-4 p-3 bg-gray-50 rounded-lg space-y-2 md:space-y-0 md:items-center md:space-x-4">
            <label class="text-sm">何日ごと: <input type="number" id="edit-repeat-interval-days" placeholder="例: 3" class="p-2 border rounded-lg w-24" min="1"></label>
            <label class="text-sm">基準日: <input type="date" id="edit-repeat-interval-start-date" class="p-2 border rounded-lg"></label>
        </div>

        <div class="flex gap-3 mt-6">
            <button id="save-repeat-edit" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">保存</button>
            <button id="cancel-repeat-edit" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="toast-notification" class="fixed top-5 right-1 bg-green-600 text-white mx-2 py-2 px-4 rounded-lg shadow-md transition-all duration-500 ease-in-out transform -translate-y-20 opacity-0 z-[2000]"></div>
<div id="reauth-notification" class="fixed top-5 right-1 bg-yellow-500 text-white mx-2 py-2 px-4 rounded-lg shadow-md transition-all duration-500 ease-in-out transform -translate-y-20 opacity-0 z-[2000] items-center gap-3 hidden">
    <span>Dbに再ログインが必要です</span>
    <button id="reauth-button" class="bg-white text-yellow-600 font-bold py-1 px-3 rounded-lg hover:bg-yellow-100">ログイン</button>
</div>

<div id="gcal-reauth-notification" class="fixed top-5 right-1 bg-yellow-500 text-white mx-2 py-2 px-4 rounded-lg shadow-md transition-all duration-500 ease-in-out transform -translate-y-20 opacity-0 z-[2000] items-center gap-3 hidden">
    <span>Gcalに再ログインが必要です</span>
    <button id="gcal-reauth-button" class="bg-white text-yellow-600 font-bold py-1 px-3 rounded-lg hover:bg-yellow-100">ログイン</button>
</div>

<script src="https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js"></script>

<script>

    document.addEventListener('DOMContentLoaded', () => {
	    const GCAL_CLIENT_ID = '586393061673-oq4dns80ldipqksu7tm5ut0nd6cipdb0.apps.googleusercontent.com';
	    const GCAL_SCOPES = 'https://www.googleapis.com/auth/calendar.readonly';

        // --- フローティング要素のキーボード追従と滑らかスクロール対策 ---
		function setupFloatingElementsStick() {
		    const bar = document.getElementById('floating-task-bar');
		    const syncButtonContainer = document.getElementById('sync-button-floating-container');
		
		    if (!bar || !syncButtonContainer) return;
		
		    let ticking = false;
		
		function updateElementsPosition() {
		    const bar = document.getElementById('floating-task-bar');
		    const syncButtonContainer = document.getElementById('sync-button-floating-container');
		    if (!bar || !syncButtonContainer) return;
		
		    // PC表示時の処理 (変更なし)
		    if (!isMobile()) {
				bar.style.position = ''; 
	            bar.style.bottom = '';
		        bar.style.top = '';
		        syncButtonContainer.style.position = '';
		        syncButtonContainer.style.bottom = '';
		        syncButtonContainer.style.top = '';
		        return;
		    }
		
		    // モバイル表示時の処理 (absolute + 無限スクロール制限)
		    const scrollY = window.scrollY || 0;
		    const viewportHeight = window.innerHeight;
		    const actualBarHeight = bar.offsetHeight;
		    const barHeight = actualBarHeight > 0 ? actualBarHeight : 80;
		
		    const documentHeight = Math.max(
		        document.body.scrollHeight, 
		        document.documentElement.scrollHeight,
		        document.body.offsetHeight, 
		        document.documentElement.offsetHeight
		    );
		    
		    const maxScroll = documentHeight - viewportHeight;
		    const absoluteBottomTop = documentHeight - barHeight;
		
		    let newBarTop;
		    let newSyncButtonTop;
		    
		    if (scrollY >= maxScroll) {
		        newBarTop = absoluteBottomTop;
		        
		    } 
		    else {
		        const scrollBottom = scrollY + viewportHeight;
		        newBarTop = scrollBottom - barHeight;
		    }
		    bar.style.position = 'absolute';
		    bar.style.top = newBarTop + 'px';
		    const syncButtonHeight = syncButtonContainer.offsetHeight;
		    newSyncButtonTop = newBarTop - syncButtonHeight - 16;
		    syncButtonContainer.style.position = 'absolute';
		    syncButtonContainer.style.top = newSyncButtonTop + 'px';		    
		}
		
		    function requestTick() {
		        if (!ticking) {
		            requestAnimationFrame(() => {
		                updateElementsPosition();
		                ticking = false;
		            });
		            ticking = true;
		        }
		    }
		
		    // 初期実行
		    updateElementsPosition();
		    if (isMobile()) {
		        // スクロール位置を0にしてから、requestAnimationFrameで強制的に再計算させる
		        window.scrollTo(0, 0); 
		        requestTick();
		    }
		
		    // イベントリスナー
		    window.addEventListener('scroll', requestTick, { passive: true });
		    window.addEventListener('resize', requestTick);
		    
		    // visualViewportのイベントも追加（キーボード表示時の対応）
		    if (window.visualViewport) {
		        window.visualViewport.addEventListener('resize', requestTick);
		        window.visualViewport.addEventListener('scroll', requestTick);
		    }
		}

        // --- DROPBOX SYNC START ---
        const dailyTaskListApp = window.dailyTaskListApp = {
            dropboxFilePath: '/DailyTaskListData.json', // Dropbox App Folder内のパス
            dbx: null,
            saveTimeout: null,
			// --- Google Calendar Properties ---
		    gcalApiClient: null,
		    gcalTokenClient: null,
			gcalTokenRefreshPromise: null,
		    gcalAuthorizeButton: document.getElementById('gcal_authorize_button'),
		    gcalSignoutButton: document.getElementById('gcal_signout_button'),
		    gcalAuthContainer: document.getElementById('gcal-auth-container'),
		    gcalSignoutContainer: document.getElementById('gcal-signout-container'),
		    gcalAuthStatusEl: document.getElementById('gcal-auth-status'),
		    gcalStatusEl: document.getElementById('gcal-status'),
		    gcalCalendarsListEl: document.getElementById('gcal-calendars-list'),
            gcalReauthNotification: document.getElementById('gcal-reauth-notification'),
            gcalReauthButton: document.getElementById('gcal-reauth-button'),
            // DOM Elements
            authorizeButton: document.getElementById('authorize_button'),
            signoutButton: document.getElementById('signout_button'),
            authContainer: document.getElementById('auth-container'),
            signoutContainer: document.getElementById('signout_container'),
            authStatusEl: document.getElementById('auth-status'),
            driveStatusEl: document.getElementById('drive-status'),
			syncDataFab: document.getElementById('sync-button-floating-container'),
		    reauthNotification: document.getElementById('reauth-notification'),
		    reauthButton: document.getElementById('reauth-button'),
            updateReauthUi: function(show) {
                if (show) {
                    this.reauthNotification.classList.remove('hidden');
                    // 少し遅延させてから表示アニメーションを開始
                    setTimeout(() => {
                        this.reauthNotification.classList.remove('-translate-y-20', 'opacity-0');
                        this.reauthNotification.style.display = 'flex';
                    }, 50);
                } else {
                    this.reauthNotification.classList.add('-translate-y-20', 'opacity-0');
                    // アニメーション完了後に非表示にする
                    setTimeout(() => {
                        this.reauthNotification.classList.add('hidden');
                        this.reauthNotification.style.display = 'none';
                    }, 500);
                }
            },

            updateGCalReauthUi: function(show) {
                if (show) {
                    this.gcalReauthNotification.classList.remove('hidden');
                    setTimeout(() => {
                        this.gcalReauthNotification.classList.remove('-translate-y-20', 'opacity-0');
                        this.gcalReauthNotification.style.display = 'flex';
                    }, 50);
                } else {
                    this.gcalReauthNotification.classList.add('-translate-y-20', 'opacity-0');
                    setTimeout(() => {
                        this.gcalReauthNotification.classList.add('hidden');
                        this.gcalReauthNotification.style.display = 'none';
                    }, 500);
                }
            },
			
            updateAuthUi: function(isLoggedIn) {
		        this.authContainer.classList.toggle('hidden', isLoggedIn);
		        this.signoutContainer.classList.toggle('hidden', !isLoggedIn);
		        
		        if (isLoggedIn) {
		            this.authStatusEl.textContent = 'Dropboxにログイン済みです。';
		            this.syncDataFab.innerHTML = `
		                <button id="sync-data-btn-floating" class="fab bg-white text-blue-60"> 
		                    <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" />
                            </svg>
		                </button>
		            `;
		            this.syncDataFab.querySelector('#sync-data-btn-floating').addEventListener('click', () => {
		                this.loadStateFromDropbox();
		            });
		
		        } else {
		            this.driveStatusEl.textContent = 'ログインするとデータを同期できます。';
		            this.syncDataFab.innerHTML = '';
		        }
		    },

			loadStateFromDropbox: async function() {
			    if (!this.dbx) {
			        alert('Dropboxにログインしてください。');
			        return;
			    }
			    this.driveStatusEl.textContent = 'Dropboxからデータを読み込み中...';
			    try {
			        const response = await this.dbx.filesDownload({ path: this.dropboxFilePath });
			        const fileContent = await response.result.fileBlob.text();
			        const importedData = JSON.parse(fileContent);
			
			        // --- セクション情報の復元（タスク復元より前に実行） ---
			        if (importedData.sections && Array.isArray(importedData.sections)) {
			            state.sections = importedData.sections;
			            state.sections.sort((a, b) => a.startTime.localeCompare(b.startTime));
			        }
			
			        // --- Custom Merge Logic for dailyTasks ---
			        const driveDailyTasks = importedData.dailyTasks || {};
			        const localDailyTasks = state.dailyTasks;
			        const allDailyDates = new Set([...Object.keys(localDailyTasks), ...Object.keys(driveDailyTasks)]);
			        
			        allDailyDates.forEach(date => {
			            const localTasksForDate = localDailyTasks[date] || [];
			            const driveTasksForDate = driveDailyTasks[date] || [];
			            const combinedTasks = [...localTasksForDate, ...driveTasksForDate];
			            const taskMap = new Map();
			        
			            for (const task of combinedTasks) {
			                const key = task.originRepeatId
			                    ? `repeat-${task.originRepeatId}-${task.createdDate || date}`
			                    : `task-${task.id}`;
			        
			                if (!taskMap.has(key)) {
			                    taskMap.set(key, task);
			                } else {
			                    const existingTask = taskMap.get(key);
			                    const newTask = task;
			        
			                    const existingIsCompleted = getTaskStatus(existingTask) === 'completed';
			                    const newIsCompleted = getTaskStatus(newTask) === 'completed';
			        
			                    let taskToKeep = existingTask;
			        
			                    if (newIsCompleted && !existingIsCompleted) {
			                        taskToKeep = newTask;
			                    } else if (!newIsCompleted && existingIsCompleted) {
			                        // Do nothing, keep existing
			                    } else {
			                        const existingTimestamp = existingTask.updatedAt || '1970-01-01T00:00:00.000Z';
			                        const newTimestamp = newTask.updatedAt || '1970-01-01T00:00:00.000Z';
			                        if (newTimestamp >= existingTimestamp) {
			                            taskToKeep = newTask;
			                        }
			                    }
			                    taskMap.set(key, taskToKeep);
			                }
			            }
			            
			            let mergedTasks = Array.from(taskMap.values());
			            
			            // --- タスクをセクション順にソート ---
			            const sortedSections = [...state.sections].sort((a, b) => a.startTime.localeCompare(b.startTime));
			            const sectionOrder = ['null', ...sortedSections.map(s => s.id)];
			            
			            mergedTasks.sort((a, b) => {
			                const sectionIndexA = sectionOrder.indexOf(a.sectionId || 'null');
			                const sectionIndexB = sectionOrder.indexOf(b.sectionId || 'null');
			                
			                // セクションが異なる場合はセクション順
			                if (sectionIndexA !== sectionIndexB) {
			                    return sectionIndexA - sectionIndexB;
			                }
			                
			                // 同じセクション内ではsortOrder順
			                return (a.sortOrder || 0) - (b.sortOrder || 0);
			            });
			            
			            state.dailyTasks[date] = mergedTasks;
			        });
			        // --- End of dailyTasks Merge Logic ---
			        
			        // --- Custom Merge Logic for archivedTasks ---
			        const driveArchivedTasks = importedData.archivedTasks || {};
			        const localArchivedTasks = state.archivedTasks;
			        const allArchiveDates = new Set([...Object.keys(localArchivedTasks), ...Object.keys(driveArchivedTasks)]);
			        allArchiveDates.forEach(date => {
			            const localTasks = localArchivedTasks[date] || [];
			            const driveTasks = driveArchivedTasks[date] || [];
			            const taskMap = new Map();
			            for (const task of [...localTasks, ...driveTasks]) {
			                taskMap.set(task.id, task);
			            }
			            state.archivedTasks[date] = Array.from(taskMap.values());
			        });
			        // --- End of archivedTasks Merge Logic ---
			        
			        // ---  不要なリピートタスクの削除処理(ここに一本化) ---
			        const sortedDates = Array.from(new Set([
			            ...Object.keys(state.dailyTasks), 
			            ...Object.keys(state.archivedTasks)
			        ])).sort();
			        const repeatTaskCompletionMap = new Map();
			
			        // 最初にすべての完了情報を集める (dailyTasks と archivedTasks の両方から)
			        sortedDates.forEach(date => {
			            const allTasksForDate = [
			                ...(state.dailyTasks[date] || []),
			                ...(state.archivedTasks[date] || [])
			            ];
			            allTasksForDate.forEach(task => {
			                if (task.originRepeatId && getTaskStatus(task) === 'completed') {
			                    const existing = repeatTaskCompletionMap.get(task.originRepeatId);
			                    if (!existing || date > existing) {
			                        repeatTaskCompletionMap.set(task.originRepeatId, date);
			                    }
			                }
			            });
			        });
			        
			        // 集めた完了情報をもとに、不要な未完了タスクを一度だけ削除する
			        sortedDates.forEach(date => {
			            const tasks = state.dailyTasks[date] || [];
			            state.dailyTasks[date] = tasks.filter(task => {
			                if (!task.originRepeatId) return true; // リピート由来でなければ保持
			                
			                const completedDate = repeatTaskCompletionMap.get(task.originRepeatId);
			                if (!completedDate) return true; // 完了記録がなければ保持
			                
			                const taskCreatedDate = task.createdDate || date;
			                if (taskCreatedDate > completedDate) {
			                    // 完了日より後に正規に作られたタスクは保持
			                    return true;
			                }
			                
			                if (getTaskStatus(task) === 'completed') {
			                    // 完了済みのタスクは保持
			                    return true;
			                }
			                
			                // 完了日以前に作られた未完了タスク(=不要な先送りタスク)は削除
			                return false;
			            });
			        });
			        // --- End of リピートタスク重複削除処理 ---
			
			        if (importedData.projects) state.projects = importedData.projects;
			        if (importedData.repeatTasks) state.repeatTasks = importedData.repeatTasks;
			        state.lastDate = importedData.lastDate || state.lastDate;
			        
			        stopActiveTimer();
			        state.viewDate = getFormattedDate(new Date());
			        const tasksToday = getTasksForViewDate();
			        const firstUncompletedTask = tasksToday.find(t => getTaskStatus(t) !== 'completed');
			        if (firstUncompletedTask) {
			            state.focusedTaskId = firstUncompletedTask.id;
			        } else if (tasksToday.length > 0) {
			            state.focusedTaskId = tasksToday[tasksToday.length - 1].id;
			        } else {
			            state.focusedTaskId = null;
			        }
			        Object.values(state.dailyTasks).flat().forEach(task => updateTaskStatus(task));
			        
			        restoreRunningTaskState();
			        saveState(); 
			        render();
			        this.driveStatusEl.textContent = `Dropboxからデータを読み込みました (${new Date().toLocaleTimeString()})。`;
			        showToast('Dropboxからデータを読み込みました。');
			
			    } catch (error) {
			        if (error.status === 409) { // 409: path not found
			             this.driveStatusEl.textContent = 'データファイルが見つかりません。初回同期を開始します...';
			             await this.saveStateToDropbox(); // 初回保存
			        } else {
			            console.error('Error loading state from Dropbox:', error);
			            this.driveStatusEl.textContent = `読み込みエラー: ${error.error?.error_summary || 'Unknown error'}`;
			            const errorSummary = error.error?.error_summary || '';
			            if (error.status === 401 || errorSummary.includes('expired_access_token')) {
			                this.updateReauthUi(true);
			                this.driveStatusEl.textContent = '認証が切れました。再ログインしてください。';
			            }
			        }
			    }
			},
            
			saveStateToDropbox: async function() {
			    const accessToken = localStorage.getItem('dropbox_access_token');
			    if (!this.dbx || !accessToken) {
			        console.log('Dropbox not authenticated, skipping cloud save');
			        return;
			    }
			    
			    this.driveStatusEl.textContent = 'Dropboxへ保存準備中...';
			    const cleanedDailyTasks = {};
			    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
			
			    for (const dateKey in state.dailyTasks) {
			        const filteredTasks = state.dailyTasks[dateKey].filter(task => {
			            // isDeletedフラグがないか、あっても30日以内のものだけを残す
			            return !task.isDeleted || (task.updatedAt && task.updatedAt > thirtyDaysAgo);
			        });
			        // フィルタリングした結果、タスクが1件以上残っている場合のみその日付のデータを保存する
			        if (filteredTasks.length > 0) {
			            cleanedDailyTasks[dateKey] = filteredTasks;
			        }
			    }
			    
			    const dataToSave = {
			        dailyTasks: cleanedDailyTasks,
			        projects: state.projects,
			        repeatTasks: state.repeatTasks,
			        sections: state.sections,
			        archivedTasks: state.archivedTasks,
			        lastDate: state.lastDate,
			        updatedAt: new Date().toISOString()
			    };
			    
			    this.driveStatusEl.textContent = 'Dropboxへ保存中...';
			    try {
			        await this.dbx.filesUpload({
			            path: this.dropboxFilePath,
			            contents: JSON.stringify(dataToSave, null, 2),
			            mode: 'overwrite'
			        });
			        this.driveStatusEl.textContent = `Dropboxに保存しました (${new Date().toLocaleTimeString()})。`;
			    } catch (error) {
			        console.error('Error saving state to Dropbox:', error);
			        this.driveStatusEl.textContent = `保存エラー: ${error.error?.error_summary || 'Unknown error'}`;
			        if (error.status === 401) { // 認証エラー
			            this.updateAuthUi(false);
			            this.driveStatusEl.textContent = '認証が切れました。再ログインしてください。';
			            this.updateReauthUi(true);
			        }
			    }
			}
        };
        
		// Dropbox 同期機能の初期化
		async function initializeDropboxSync() {
		    // ここにDropboxアプリのクライアントIDを設定してください
		    const DROPBOX_CLIENT_ID = '0fno7q10xgfdyki';
		    const REDIRECT_URI = window.location.origin + window.location.pathname; 
		    // 例: https://morvra.github.io/taskrono または https://morvra.github.io/taskrono/
		
		    if (DROPBOX_CLIENT_ID === 'YOUR_CLIENT_ID') {
		        console.warn("DropboxのクライアントIDが設定されていません。");
		        dailyTaskListApp.authorizeButton.textContent = '設定が必要です';
		        dailyTaskListApp.authorizeButton.disabled = true;
		        return;
		    }
		
            // localStorageからトークンを読み込み、インスタンス作成時に渡す
            const accessToken = localStorage.getItem('dropbox_access_token');
            const refreshToken = localStorage.getItem('dropbox_refresh_token');

		    const dbx = new Dropbox.Dropbox({ 
                clientId: DROPBOX_CLIENT_ID,
                accessToken,
                refreshToken
            });

			dailyTaskListApp.dbx = dbx; // アプリケーションオブジェクトにインスタンスをセット

			dailyTaskListApp.reauthButton.addEventListener('click', () => {
                dailyTaskListApp.authorizeButton.click();
            });
		
		    // URLに認証コードがあるか確認 (OAuthリダイレクト後)
		    const urlParams = new URLSearchParams(window.location.search);
		    const authCode = urlParams.get('code');
		
		    if (authCode) {
		        try {
		            // --- PKCE: 認証開始時に保存した code_verifier を復元 ---
		            const savedVerifier = sessionStorage.getItem('dropbox_pkce_code_verifier');
		            if (savedVerifier && dbx && dbx.auth) {
		                try { dbx.auth.codeVerifier = savedVerifier; } catch (e) { /* ignore */ }
		            }
		
		            // 認証コードをアクセストークンとリフレッシュトークンに交換
		            const response = await dbx.auth.getAccessTokenFromCode(REDIRECT_URI, authCode);
                    
		            const { result } = response;
                    const newAccessToken = result.access_token;
                    const newRefreshToken = result.refresh_token;
		
		            // 交換が成功したら、保存しておいた verifier は削除
		            sessionStorage.removeItem('dropbox_pkce_code_verifier');
		
		            // URLから認証コードを削除してクリーンにする
		            window.history.replaceState({}, document.title, window.location.pathname);
                    
		            localStorage.setItem('dropbox_access_token', newAccessToken);
                    if (newRefreshToken) {
		                localStorage.setItem('dropbox_refresh_token', newRefreshToken);
                    }
		            dbx.auth.setAccessToken(newAccessToken);
                    if (newRefreshToken) {
		                dbx.auth.setRefreshToken(newRefreshToken);
                    }

		            dailyTaskListApp.updateAuthUi(true);
					dailyTaskListApp.updateReauthUi(false);
		            dailyTaskListApp.loadStateFromDropbox();

		        } catch (error) {
		            console.error('Error getting access token from code:', error);
		            const detail =
		                (error && (error.error_summary || error.error || error.error_description)) ||
		                JSON.stringify(error);
		            dailyTaskListApp.driveStatusEl.textContent = `認証交換エラー: ${detail}`;
		            alert('Dropboxの認証に失敗しました。詳細はコンソールを確認してください。');
		        }
		    } else {
		        // ローカルストレージにトークンがあるか確認
		        if (accessToken) {
		            // トークンの有効性を確認（このAPI呼び出しにより、期限切れならSDKが自動でリフレッシュを試みる）
		            try {
		                await dbx.usersGetCurrentAccount();
		                dailyTaskListApp.updateAuthUi(true);
						dailyTaskListApp.updateReauthUi(false);
		                dailyTaskListApp.loadStateFromDropbox();
		            } catch (error) {
		                // トークンが無効だった場合（リフレッシュも失敗した場合）
		                console.error('Stored token invalid:', error);
		                localStorage.removeItem('dropbox_access_token');
		                localStorage.removeItem('dropbox_refresh_token');
		                dailyTaskListApp.dbx = null;
		                dailyTaskListApp.updateAuthUi(false);
						dailyTaskListApp.updateReauthUi(true);
		            }
		        } else {
		            dailyTaskListApp.updateAuthUi(false);
		        }
		    }
		
		    // --- 認証開始処理 ---
		    dailyTaskListApp.authorizeButton.addEventListener('click', async () => {
		        try {
		            const authUrl = await dbx.auth.getAuthenticationUrl(
		                REDIRECT_URI,         // Redirect URI
		                undefined,            // state
		                'code',               // authType
		                'offline',            // 'offline'を指定してリフレッシュトークンを要求
		                undefined,            // scope
		                undefined,            // includeGrantedScopes
		                true                  // usePKCE
		            );
		            // SDKが生成した code_verifier を sessionStorage に保存
		            try {
		                const codeVerifier = dbx.auth && dbx.auth.codeVerifier;
		                if (codeVerifier) {
		                    sessionStorage.setItem('dropbox_pkce_code_verifier', codeVerifier);
		                }
		            } catch (e) {
		                console.warn('Failed to store Dropbox PKCE code_verifier:', e);
		            }
		            // ユーザーをDropboxの認証ページへリダイレクト
		            window.location.href = authUrl;
		        } catch (e) {
		            console.error('Error creating Dropbox auth URL:', e);
		            alert('Dropbox認証用URLの生成に失敗しました。');
		        }
		    });
		
		    // --- ログアウト処理 ---
		    dailyTaskListApp.signoutButton.addEventListener('click', async () => {
		        if (!dailyTaskListApp.dbx) return;
		        try {
		            await dailyTaskListApp.dbx.authTokenRevoke();
		        } catch (error) {
		            console.error('Failed to revoke token', error);
		        } finally {
		            localStorage.removeItem('dropbox_access_token');
		            localStorage.removeItem('dropbox_refresh_token');
		            dailyTaskListApp.dbx = null;
		            dailyTaskListApp.updateAuthUi(false);
					dailyTaskListApp.updateReauthUi(false);
		        }
		    });
		}
		// --- DROPBOX SYNC END ---

		// --- GOOGLE CALENDAR SYNC START ---
        // Google Calendar連携機能の初期化
        function initializeGCalSync() {
            if (GCAL_CLIENT_ID.startsWith('YOUR_GOOGLE_CLIENT_ID')) {
                console.warn("GoogleカレンダーのクライアントIDが設定されていません。");
                dailyTaskListApp.gcalAuthorizeButton.textContent = '設定が必要です';
                dailyTaskListApp.gcalAuthorizeButton.disabled = true;
                return;
            }

            // GSI Clientの初期化
            dailyTaskListApp.gcalTokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GCAL_CLIENT_ID,
                scope: GCAL_SCOPES,
                callback: (tokenResponse) => {
                    if (tokenResponse.error) {
                        console.error("Google Token Error:", tokenResponse.error, tokenResponse.error_description || "No description.");
                        if (dailyTaskListApp.gcalTokenRefreshPromise) {
                            // サイレント更新が失敗した場合の処理
                            dailyTaskListApp.gcalTokenRefreshPromise.reject(new Error(tokenResponse.error));
                            dailyTaskListApp.updateGCalReauthUi(true); // 新しいUIを表示
                        } else {
                            // 手動ログインが失敗した場合の処理
                            showToast('Googleの認証に失敗しました。', 5000);
                        }
                        dailyTaskListApp.updateGCalAuthUi(false);
                        dailyTaskListApp.gcalStatusEl.textContent = '再ログインが必要です。';
                        return;
                    }

                    // 正常なトークン取得処理
                    if (tokenResponse.access_token) {
                        dailyTaskListApp.updateGCalReauthUi(false); // 再認証UIを隠す
                        localStorage.setItem('gcal_access_token', tokenResponse.access_token);
                        gapi.client.setToken({ access_token: tokenResponse.access_token });
                        
                        if (dailyTaskListApp.gcalTokenRefreshPromise) {
                            dailyTaskListApp.gcalTokenRefreshPromise.resolve();
                        } else {
                            dailyTaskListApp.gcalStatusEl.textContent = 'Googleにログインしました。';
                            dailyTaskListApp.updateGCalAuthUi(true);
                            dailyTaskListApp.loadAndRenderGCalCalendars();
                        }
                    }
                },
            });

            // API Clientの初期化
            gapi.load('client', async () => {
                await gapi.client.init({
                    discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"],
                });

                const accessToken = localStorage.getItem('gcal_access_token');
                if (accessToken) {
                    gapi.client.setToken({ access_token: accessToken });
                    try {
                        await dailyTaskListApp.gcalApiHelper(() => gapi.client.calendar.calendarList.list({maxResults: 1}));
                        // gcalApiHelper が成功した場合のみUIをログイン済みにし、カレンダーを読み込む
                        dailyTaskListApp.updateGCalAuthUi(true);
                        await dailyTaskListApp.loadAndRenderGCalCalendars();
                    } catch (e) {
                         console.error("Could not initialize Google Calendar on load:", e.message);
                    }
                } else {
                    dailyTaskListApp.updateGCalAuthUi(false);
                }
            });

            dailyTaskListApp.gcalAuthorizeButton.addEventListener('click', () => dailyTaskListApp.gcalHandleAuthClick());
            dailyTaskListApp.gcalSignoutButton.addEventListener('click', () => dailyTaskListApp.gcalHandleSignoutClick());
            // 新しい再認証ボタンのイベントリスナー
            dailyTaskListApp.gcalReauthButton.addEventListener('click', () => {
                dailyTaskListApp.updateGCalReauthUi(false);
                dailyTaskListApp.gcalHandleAuthClick();
            });
        }

        // dailyTaskListAppオブジェクトにGoogleカレンダー関連のメソッドを追加
        Object.assign(dailyTaskListApp, {
            // Google認証UIの状態を更新
            updateGCalAuthUi: function(isLoggedIn) {
                this.gcalAuthContainer.classList.toggle('hidden', isLoggedIn);
                this.gcalSignoutContainer.classList.toggle('hidden', !isLoggedIn);
				const loadGCalEventsBtn = document.getElementById('load-gcal-events-btn');
                if (loadGCalEventsBtn) {
                    // ログインしている場合(isLoggedIn=true)はhiddenクラスを削除し、
                    // ログインしていない場合はhiddenクラスを追加する
                    loadGCalEventsBtn.classList.toggle('hidden', !isLoggedIn);
                }
                if (isLoggedIn) {
                    this.gcalAuthStatusEl.textContent = 'Googleにログイン済みです。';
                } else {
                    this.gcalStatusEl.textContent = 'ログインするとカレンダーを連携できます。';
                }
            },
            
            // Google認証ボタンクリック時の処理
            gcalHandleAuthClick: function() {
                if (this.gcalTokenClient) {
                    this.gcalTokenClient.requestAccessToken({ prompt: 'consent' });
                }
            },

            // Googleログアウトボタンクリック時の処理
            gcalHandleSignoutClick: function() {
                const accessToken = localStorage.getItem('gcal_access_token');
                if (accessToken) {
                    google.accounts.oauth2.revoke(accessToken, () => {
                        console.log('Google access token revoked.');
                    });
                }
                localStorage.removeItem('gcal_access_token');
                localStorage.removeItem('gcal_refresh_token');
                gapi.client.setToken(null);
                this.updateGCalAuthUi(false);
                this.gcalCalendarsListEl.innerHTML = '';
            },
			
			// Google Calendar API呼び出しのラッパー関数（認証エラーハンドリング付き）
            gcalApiHelper: async function(apiCall) {
                try {
                    return await apiCall();
                } catch (error) {
                    const isAuthError = (error.status === 401) || (error.result && error.result.error && error.result.error.code === 401);
                    if (isAuthError) {
                        console.log('Google API authentication error. User re-authentication required.');
                        this.updateGCalReauthUi(true);
                        this.updateGCalAuthUi(false);
                        localStorage.removeItem('gcal_access_token');
                        throw new Error("Google authentication required. Please log in again.");
                    } else {
                        throw error;
                    }
                }
            },
            
            // ユーザーのカレンダー一覧を取得して表示
            loadAndRenderGCalCalendars: async function() {
                this.gcalStatusEl.textContent = 'カレンダー一覧を読み込み中...';
                try {
                    const response = await this.gcalApiHelper(() => gapi.client.calendar.calendarList.list());
                    const calendars = response.result.items;
                    this.gcalCalendarsListEl.innerHTML = '';

                    const selectedCalendars = JSON.parse(localStorage.getItem('gcal_selected_calendars') || '[]');

                    calendars.forEach(calendar => {
                        const isChecked = selectedCalendars.includes(calendar.id);
                        const div = document.createElement('div');
                        div.className = 'flex items-center';
                        div.innerHTML = `
                            <input type="checkbox" id="cal-${calendar.id}" value="${calendar.id}" class="form-checkbox h-4 w-4 text-blue-600" ${isChecked ? 'checked' : ''}>
                            <label for="cal-${calendar.id}" class="ml-2 text-sm">${escapeHtml(calendar.summary)}</label>
                        `;
                        this.gcalCalendarsListEl.appendChild(div);
                    });
                    
                    this.gcalCalendarsListEl.addEventListener('change', () => this.saveSelectedCalendars());
                    this.gcalStatusEl.textContent = '読み込むカレンダーを選択してください。';

                } catch (error) {
                    console.error('Error fetching calendars:', error);
                    this.gcalStatusEl.textContent = 'カレンダーの読み込みに失敗しました。';
                }
            },

            // 選択されたカレンダーのIDをlocalStorageに保存
            saveSelectedCalendars: function() {
                const selectedIds = Array.from(this.gcalCalendarsListEl.querySelectorAll('input:checked')).map(input => input.value);
                localStorage.setItem('gcal_selected_calendars', JSON.stringify(selectedIds));
                showToast('カレンダーの設定を保存しました。');
            },

            // Googleカレンダーから指定日の予定を取得してタスクとして追加
            importGoogleCalendarEvents: async function(dateStr) {
                const selectedCalendarIds = JSON.parse(localStorage.getItem('gcal_selected_calendars') || '[]');
                if (!gapi.client.getToken() || selectedCalendarIds.length === 0) {
                    if(document.activeElement.id === 'load-gcal-events-btn') {
                         alert('読み込むカレンダーが選択されていません。データ管理タブで設定してください。');
                    }
                    return;
                }

                showToast('Googleカレンダーから予定を読み込み中...');
                
                try {
                    const timeMin = new Date(dateStr);
                    timeMin.setHours(0, 0, 0, 0);
                    const timeMax = new Date(dateStr);
                    timeMax.setHours(23, 59, 59, 999);

                    const batch = gapi.client.newBatch();
                    selectedCalendarIds.forEach(calendarId => {
                        batch.add(gapi.client.calendar.events.list({
                            'calendarId': calendarId,
                            'timeMin': timeMin.toISOString(),
                            'timeMax': timeMax.toISOString(),
                            'showDeleted': false,
                            'singleEvents': true,
                            'orderBy': 'startTime'
                        }));
                    });

                    const response = await this.gcalApiHelper(() => batch);
                    let allEvents = [];
                    Object.values(response.result).forEach(res => {
                        if (res.result.items) {
                            allEvents.push(...res.result.items);
                        }
                    });

                    allEvents.sort((a, b) => {
                        const aStart = new Date(a.start.dateTime || a.start.date);
                        const bStart = new Date(b.start.dateTime || b.start.date);
                        return aStart - bStart;
                    });
                    
                    if (!state.dailyTasks[dateStr]) {
                        state.dailyTasks[dateStr] = [];
                    }
                    const existingEventIds = new Set(state.dailyTasks[dateStr].map(t => t.googleEventId));
                    let addedCount = 0;

                    const newTasks = allEvents
                        .filter(event => !existingEventIds.has(event.id))
                        .map(event => {
                            let estimatedTime = 0;
                            if (event.start.dateTime && event.end.dateTime) {
                                const start = new Date(event.start.dateTime);
                                const end = new Date(event.end.dateTime);
                                estimatedTime = Math.round((end - start) / (1000 * 60));
                            }
                            
                            addedCount++;
                            return {
                                id: 't' + Date.now() + Math.random(),
                                name: `🗓 ${event.summary}`,
                                estimatedTime: estimatedTime,
                                memo: event.description || '',
                                origin: 'google_calendar',
                                googleEventId: event.id,
								sectionId: null,
                                status: 'pending',
                                startTime: null,
                                endTime: null,
                                createdDate: dateStr,
                                updatedAt: new Date().toISOString(),
                            };
                        });

                    if (newTasks.length > 0) {
                        const tasks = state.dailyTasks[dateStr];
                        // 「未着手(pending)」の最初のタスクを探して、その手前に挿入する
                        let insertIndex = tasks.findIndex(t => t.status === 'pending');
                        
                        // 未着手タスクがない場合は、完了タスクの先頭（＝未完了タスクの末尾）を探す
                        if (insertIndex === -1) {
                            insertIndex = tasks.findIndex(t => t.status === 'completed');
                        }

                        // それでも挿入場所が見つからない場合（リストが空か、すべて実行中の場合）は末尾に追加
                        if (insertIndex === -1) {
                            insertIndex = tasks.length;
                        }

                        tasks.splice(insertIndex, 0, ...newTasks);
                        saveAndRender();
                    }
                    showToast(`${addedCount}件の予定を読み込みました。`);

                } catch (error) {
                    console.error('Error fetching Google Calendar events:', error);
                    showToast('予定の読み込みに失敗しました。', 5000);
                }
            }
        });
        // --- GOOGLE CALENDAR SYNC END ---

        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast-notification');
            if (!toast) return;

            toast.textContent = message;
            toast.classList.remove('-translate-y-20', 'opacity-0');

            // 一定時間後に非表示
            setTimeout(() => {
                toast.classList.add('-translate-y-20', 'opacity-0');
            }, duration);
        }

        // State
        const state = {
            dailyTasks: {}, 
            projects: [],
            repeatTasks: [],
			sections: [],
            archivedTasks: {},
            viewDate: null, 
            lastDate: null,
            archiveViewDate: null,
            archiveView: 'date',
            settings: {
                dayChangeHour: 4, 
            },
            activeTimerId: null,
            activeTaskId: null,
            focusedTaskId: null,
			focusedSubtaskId: null,
			openTaskIds: new Set(),
            editingTaskId: null,
            editingTaskDateKey: null, 
            editingRepeatId: null,
            editingMemoTaskId: null
        };

        // DOM refs
        const tabs = document.querySelectorAll('.tab-link');
        const currentDateEl = document.getElementById('current-date');
        const totalEstimatedEndTimeEl = document.getElementById('total-estimated-end-time');

		function updateSortOrderAndTimestamps(dateKey) {
			const tasks = state.dailyTasks[dateKey] || [];
			const now = new Date().toISOString();
			tasks.forEach((task, index) => {
				task.sortOrder = index;
				// Only update the timestamp if the order actually changed
				// to avoid unnecessary saves during simple reads.
				if (!task.updatedAt || task.sortOrder !== index) {
					task.updatedAt = now;
				}
			});
		}

		// サブタスク関連
		function toggleSubtaskView(taskId) {
            // stateの更新（どのタスクが開いているかの情報を更新）
		    if (state.openTaskIds.has(taskId)) {
		        state.openTaskIds.delete(taskId);
		    } else {
		        state.openTaskIds.add(taskId);
		    }

		    if (taskId === state.focusedTaskId) {
		        saveAndRender();
		    } else {
		        const subtaskContainer = document.getElementById(`subtasks-${taskId}`);
		        if (subtaskContainer) {
		            subtaskContainer.classList.toggle('open', state.openTaskIds.has(taskId));
		        }
		        saveState();
		    }
	    }

	
		function toggleSubtaskCompletion(taskId, subtaskId, isCompleted) {
			const task = getTasksForViewDate().find(t => t.id === taskId);
			if (task && task.subtasks) {
				const subtask = task.subtasks.find(st => st.id === subtaskId);
				if (subtask) {
					subtask.completed = isCompleted;
					task.updatedAt = new Date().toISOString();

                    Array.from(document.querySelectorAll(`.subtask-item [data-subtask-id="${subtaskId}"]`)).forEach(checkbox => {
                        const item = checkbox.closest('.subtask-item');
                        if (item) {
                            item.classList.toggle('completed', isCompleted);
                            checkbox.checked = isCompleted;
                        }
                    });

					saveState();
				}
			}
		}
	
	    function renderSubtasksInModal(type, taskId) {
	        const isRepeat = type === 'repeat';
	        const container = document.getElementById(isRepeat ? 'edit-repeat-subtasks' : 'edit-task-subtasks');
	        const task = isRepeat ? state.repeatTasks.find(t => t.id === taskId) : getTasksForViewDate().find(t => t.id === taskId);
	        
	        container.innerHTML = '';
	        if (!task || !task.subtasks) return;
	
	        task.subtasks.forEach((st, index) => {
	            const item = document.createElement('div');
	            item.className = 'subtask-edit-item';
	            item.dataset.subtaskId = st.id;
	
	            item.innerHTML = `
	                <input type="checkbox" class="form-checkbox h-4 w-4 text-blue-600" ${st.completed ? 'checked' : ''} ${isRepeat ? 'disabled' : ''}>
	                <input type="text" class="flex-1 p-1 border rounded-md" value="${escapeHtml(st.name)}">
					<div class="flex items-center">
						<button class="subtask-move-up-btn text-gray-400 hover:text-blue-500 p-1" title="上へ移動">
							<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" /></svg>
						</button>
						<button class="subtask-move-down-btn text-gray-400 hover:text-blue-500 p-1" title="下へ移動">
							<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" /></svg>
						</button>
						<button class="subtask-delete-btn text-gray-400 hover:text-red-500 p-1" title="削除">
							<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
						</button>
					</div>
	            `;
	            container.appendChild(item);
	        });
	
			// イベントリスナーが重複しないようにフラグで管理
			if (!container.dataset.listenersAdded) {
				// イベント委任でクリックを処理
				container.addEventListener('click', (e) => {
					const item = e.target.closest('.subtask-edit-item');
					if (!item) return;

					if (e.target.closest('.subtask-delete-btn')) {
						item.remove();
					} else if (e.target.closest('.subtask-move-up-btn')) {
						if (item.previousElementSibling) {
							item.parentElement.insertBefore(item, item.previousElementSibling);
						}
					} else if (e.target.closest('.subtask-move-down-btn')) {
						if (item.nextElementSibling) {
							item.parentElement.insertBefore(item.nextElementSibling, item);
						}
					}
				});
		
				// モーダル内サブタスクのキーボード並び替え
				container.addEventListener('keydown', (e) => {
					if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
						 if (e.ctrlKey || e.metaKey) {
							e.preventDefault();
							const currentItem = e.target.closest('.subtask-edit-item');
							if (!currentItem) return;
							
							if (e.key === 'ArrowUp' && currentItem.previousElementSibling) {
								currentItem.parentElement.insertBefore(currentItem, currentItem.previousElementSibling);
								e.target.focus();
							} else if (e.key === 'ArrowDown' && currentItem.nextElementSibling) {
								currentItem.parentElement.insertBefore(currentItem.nextElementSibling, currentItem);
								e.target.focus();
							}
						}
					}
				});
				container.dataset.listenersAdded = 'true';
			}
	    }
	    
	    function addSubtaskToModal(type, name) {
	        const isRepeat = type === 'repeat';
	        const container = document.getElementById(isRepeat ? 'edit-repeat-subtasks' : 'edit-task-subtasks');
	        
	        const item = document.createElement('div');
	        item.className = 'subtask-edit-item';
	        item.dataset.subtaskId = 'new-st-' + Date.now();
	        
	        item.innerHTML = `
	            <input type="checkbox" class="form-checkbox h-4 w-4 text-blue-600" ${isRepeat ? 'disabled' : ''}>
	            <input type="text" class="flex-1 p-1 border rounded-md" value="${escapeHtml(name)}">
				<div class="flex items-center">
					<button class="subtask-move-up-btn text-gray-400 hover:text-blue-500 p-1" title="上へ移動">
						<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" /></svg>
					</button>
					<button class="subtask-move-down-btn text-gray-400 hover:text-blue-500 p-1" title="下へ移動">
						<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" /></svg>
					</button>
					<button class="subtask-delete-btn text-gray-400 hover:text-red-500 p-1" title="削除">
						<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
					</button>
				</div>
	        `;
	        container.appendChild(item);
	        // イベントリスナーは親コンテナで委任されているため、個別に追加する必要はありません
	        item.querySelector('input[type="text"]').focus();
	    }
	
	    function getSubtasksFromModal(type) {
	        const isRepeat = type === 'repeat';
	        const container = document.getElementById(isRepeat ? 'edit-repeat-subtasks' : 'edit-task-subtasks');
	        const subtaskItems = container.querySelectorAll('.subtask-edit-item');
	        const subtasks = [];
	        subtaskItems.forEach(item => {
	            const name = item.querySelector('input[type="text"]').value.trim();
	            if (name) {
	                subtasks.push({
	                    id: item.dataset.subtaskId.startsWith('new-st-') ? 'st' + Date.now() + Math.random() : item.dataset.subtaskId,
	                    name: name,
	                    completed: isRepeat ? false : item.querySelector('input[type="checkbox"]').checked
	                });
	            }
	        });
	        return subtasks;
	    }

        /**
         * 指定された年月の「第N・何曜日」が何日にあたるかを計算する
         * @param {number} year - 年
         * @param {number} month - 月 (0-11)
         * @param {number} week - 週 (1-4: 第N, 5: 最終)
         * @param {number} weekday - 曜日 (0:日, 1:月, ... 6:土)
         * @returns {number|null} 日付、または該当なしの場合はnull
         */
        function getNthWeekdayOfMonth(year, month, week, weekday) {
            const date = new Date(year, month, 1);
            let count = 0;
            // 最終週の場合
            if (week === 5) {
                const lastDayOfMonth = new Date(year, month + 1, 0).getDate();
                for (let day = lastDayOfMonth; day >= 1; day--) {
                    date.setDate(day);
                    if (date.getDay() === weekday) {
                        return day; // 後ろから探して最初に見つかった曜日が最終
                    }
                }
            } else { // 第1-4週の場合
                const lastDayOfMonth = new Date(year, month + 1, 0).getDate();
                for (let day = 1; day <= lastDayOfMonth; day++) {
                    date.setDate(day);
                    if (date.getDay() === weekday) {
                        count++;
                        if (count === week) {
                            return day;
                        }
                    }
                }
            }
            return null; // 該当なし
        }

		function waitForGoogleLibsAndInitialize() {
            // gapi と google の両方が使えるようになるまで待つ
            if (typeof gapi !== 'undefined' && typeof google !== 'undefined') {
                initializeGCalSync();
            } else {
                // 準備ができていなければ、100ミリ秒後にもう一度確認する
                setTimeout(waitForGoogleLibsAndInitialize, 100);
            }
        }

        // Init
        function init() {
            state.viewDate = getFormattedDate(new Date());
            loadState();
			handleUrlScheme();
            restoreRunningTaskState();
            setupEventListeners();
            initializeDropboxSync();
			waitForGoogleLibsAndInitialize();
			renderPcAddTaskButton();
            checkDayChange();
            setInterval(checkDayChange, 1000 * 60); 
            updateTitle();
            
            render();
            updateTimeDisplays();
            setInterval(updateTimeDisplays, 1000*30);
			// 分析ページなどからブラウザバックで戻ってきた際に「当日のタスク」を表示する
			window.addEventListener('pageshow', function(event) {
                // event.persistedがtrueの場合、ページはキャッシュ(bfcache)から読み込まれている
                if (event.persisted) {
                    const todayTab = document.querySelector('.tab-link[data-tab="today"]');
                    if (todayTab && !todayTab.classList.contains('active')) {
                        todayTab.click();
                    }
                }
            });
            
            window.addEventListener('resize', () => {
                const activeTab = document.querySelector('.tab-link.active').dataset.tab;
                if (['today', 'repeat', 'projects', 'archive'].includes(activeTab)) {
                    render();
                }
				renderFloatingTaskBar();
            });

            setupFloatingElementsStick(); 
        }

	function handleUrlScheme() {
	    const urlParams = new URLSearchParams(window.location.search);
	    const taskNameParam = urlParams.get('addtask');
	
	    if (!taskNameParam) return;
	
	    const taskName = taskNameParam;
	    const estimatedRaw = urlParams.get('estimated');
	    const estimatedParsed = parseInt(estimatedRaw, 10);
	    const estimatedTime = (!isNaN(estimatedParsed) && estimatedParsed >= 0) ? estimatedParsed : 5;
	    const projectName = urlParams.get('project') || null;
	
	    let projectId = null;
	    if (projectName) {
	        const project = state.projects.find(p => p.name.toLowerCase() === projectName.toLowerCase());
	        if (project) projectId = project.id;
	    }
	
	    try {
	        const cleanUrl = window.location.protocol + '//' + window.location.host + window.location.pathname + (window.location.hash || '');
	        window.history.replaceState(null, '', cleanUrl);
	    } catch (e) {
	        console.warn('URL クリーンアップに失敗しました（続行します）:', e);
	    }
	
    // タスク追加処理を「1フレーム遅らせて」実行する
    setTimeout(() => {
        try {
            // 「当日のタスク」タブを強制的に開く
            document.querySelector('.tab-link[data-tab="today"]')?.click();

            // 表示日を今日にする
            state.viewDate = getFormattedDate(new Date());

            if (typeof addTask !== 'function') {
                console.warn('addTask 関数が見つかりません。URL追加をスキップします。');
                return;
            }

            const newTask = addTask(taskName, estimatedTime, projectId, null);

            if (newTask) {
                showToast(`「${taskName}」を追加しました。`);
            }
        } catch (err) {
            console.error('URL からのタスク追加で一部処理が失敗しました:', err);
            showToast('URLからのタスク追加中に一部処理が失敗しました（詳細はコンソール）。', 5000);
        }
    }, 0);
	}

    function getTasksForViewDate() {
        const tasks = state.dailyTasks[state.viewDate] || [];
        return tasks.filter(task => !task.isDeleted);
    }

	function setTasksForViewDate(tasks) {
	    const deletedTasks = (state.dailyTasks[state.viewDate] || []).filter(task => task.isDeleted);
	    state.dailyTasks[state.viewDate] = [...tasks, ...deletedTasks];
	}

	function updateTitle() {
        const activeTask = getTasksForViewDate().find(t => t.id === state.activeTaskId);
        if (activeTask) {
            document.title = `⏱ ${activeTask.name} - Taskrono`;
        } else {
            document.title = 'Taskrono';
        }
    }

    function isMobile() {
        return window.innerWidth <= 768;
    }

    function getFormattedDate(date) {
        return new Date(date.getTime() - (state.settings.dayChangeHour * 60 * 60 * 1000))
            .toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' })
            .replace(/\//g, '-');
    }

    function getTaskStatus(task) {
        if (task.startTime && task.endTime) {
            return 'completed';
        } else if (task.startTime && !task.endTime) {
            return 'running';
        } else {
            return 'pending';
        }
    }

    function updateTaskStatus(task) {
        const tasks = getTasksForViewDate();
        const oldStatus = task.status;
        task.status = getTaskStatus(task);
        
        if (oldStatus !== 'completed' && task.status === 'completed') {
            moveTaskToCompletedSection(task.id);
        }
        else if (oldStatus !== 'running' && task.status === 'running') {
            moveTaskToTop(task.id);
        }
    }

    function moveTaskToCompletedSection(taskId) {
        const tasks = getTasksForViewDate();
        const taskIndex = tasks.findIndex(t => t.id === taskId);
        if (taskIndex === -1) return;

        const [task] = tasks.splice(taskIndex, 1);
        
        const lastCompletedIndex = tasks.map(t => t.status === 'completed').lastIndexOf(true);
        
        const insertIndex = lastCompletedIndex === -1 ? 0 : lastCompletedIndex + 1;

        tasks.splice(insertIndex, 0, task);
        setTasksForViewDate(tasks);
    }

	function moveTaskToTop(taskId) {
	    const tasks = getTasksForViewDate();
	    const taskIndex = tasks.findIndex(t => t.id === taskId);
	    if (taskIndex !== -1) {
	        const task = tasks[taskIndex];
	        const uncompletedTasks = tasks.filter(t => t.status !== 'completed' && t.id !== taskId);
	
	        if (uncompletedTasks.length === 0) {
	            return;
	        }
	
	        const [movedTask] = tasks.splice(taskIndex, 1);
	        const firstUncompletedIndex = tasks.findIndex(t => t.status !== 'completed');
	        
	        const insertIndex = firstUncompletedIndex !== -1 ? firstUncompletedIndex : 0;
	        
	        tasks.splice(insertIndex, 0, movedTask);
	        setTasksForViewDate(tasks);
	    }
	}

    function positionTooltip(tooltipContainer) {
        const tooltip = tooltipContainer.querySelector('.custom-tooltip');
        const rect = tooltipContainer.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        
        if (rect.top - tooltipRect.height < 10) {
            tooltip.classList.add('tooltip-bottom');
            tooltip.classList.remove('tooltip-top');
        } else {
            tooltip.classList.add('tooltip-top');
            tooltip.classList.remove('tooltip-bottom');
        }
    }

    function loadState() {
        const defaults = {
            dailyTasks: {},
            projects: [
                { id: 'p' + Date.now(), name: '仕事', color: '#4a90e2' },
                { id: 'p' + (Date.now()+1), name: '学習', color: '#50e3c2' },
                { id: 'p' + (Date.now()+2), name: 'プライベート', color: '#f5a623' },
            ],
            repeatTasks: [],
            sections: [
                { id: 's' + (Date.now()+0), name: 'セクションA', startTime: '04:00' },
                { id: 's' + (Date.now()+1), name: 'セクションB', startTime: '09:00' },
                { id: 's' + (Date.now()+2), name: 'セクションC', startTime: '12:00' },
                { id: 's' + (Date.now()+3), name: 'セクションD', startTime: '16:00' },
                { id: 's' + (Date.now()+4), name: 'セクションE', startTime: '19:00' },
                { id: 's' + (Date.now()+5), name: 'セクションF', startTime: '23:00' }
            ],
            archivedTasks: {},
            lastDate: getFormattedDate(new Date()),
        };

        const oldTasks = localStorage.getItem('dtl_tasks');
        const newTasks = localStorage.getItem('dtl_dailyTasks');
        if (oldTasks && !newTasks) {
            const parsedOldTasks = JSON.parse(oldTasks);
            if (Array.isArray(parsedOldTasks) && parsedOldTasks.length > 0) {
                const today = getFormattedDate(new Date());
                state.dailyTasks[today] = parsedOldTasks;
                localStorage.removeItem('dtl_tasks');
            }
        }

        Object.keys(defaults).forEach(k => {
            const saved = localStorage.getItem(`dtl_${k}`);
            if ((k === 'archivedTasks' || k === 'dailyTasks') && !saved) {
                state[k] = defaults[k];
            } else {
                 state[k] = saved ? JSON.parse(saved) : defaults[k];
            }
        });

        // セクションを開始時刻でソート
        state.sections.sort((a, b) => a.startTime.localeCompare(b.startTime));

        Object.values(state.dailyTasks).flat().forEach(task => {
            updateTaskStatus(task);
        });
    }

	function saveState() {
	    Object.keys(state).forEach(k => {
	        if (k !== 'settings' && k !== 'archiveView' && k !== 'selectedArchiveProject') {
	            if (k === 'openTaskIds') {
	                localStorage.setItem(`dtl_${k}`, JSON.stringify(Array.from(state[k])));
	            } else {
	                localStorage.setItem(`dtl_${k}`, JSON.stringify(state[k]));
	            }
	        }
	    });
	
	    const savedOpenTaskIds = localStorage.getItem('dtl_openTaskIds');
	    if (savedOpenTaskIds) {
	        state.openTaskIds = new Set(JSON.parse(savedOpenTaskIds));
	    }
	    
	    const app = window.dailyTaskListApp;
	    const accessToken = localStorage.getItem('dropbox_access_token');
	    if (app.dbx && accessToken) { // Dropboxインスタンスとトークンの両方が存在する場合のみ
	        if (app.saveTimeout) clearTimeout(app.saveTimeout);
	        app.saveTimeout = setTimeout(() => app.saveStateToDropbox(), 2000);
	    }
	}

    function restoreRunningTaskState() {
        // 既に動いているタイマーがあれば止める
        stopActiveTimer();

        const tasks = getTasksForViewDate();
        const runningTask = tasks.find(t => t.status === 'running');
        
        if (runningTask) {
            state.activeTaskId = runningTask.id;
            state.activeTimerId = setInterval(() => {
                // 実行中のタスクの最新の状態を取得
                const currentTask = getTasksForViewDate().find(t => t.id === state.activeTaskId);
                // タスクが存在し、かつ実行中であることを確認
                if (!currentTask || currentTask.status !== 'running') {
                    stopActiveTimer(); // 状態が変化していればタイマーを停止
                    updateTitle();
                    renderFloatingTaskBar();
                    return;
                }
                const currentActualTime = calculateActualTime(currentTask);
                const timeEl = document.querySelector(`[data-task-id="${currentTask.id}"] .time-actual`);
                if (timeEl) {
                    timeEl.textContent = formatTime(currentActualTime);
                }
            }, 1000);
        }
    }
		
    async function checkDayChange() {
            const today = getFormattedDate(new Date());
            if (state.lastDate !== today) {
                console.log(`Date changed: ${state.lastDate} -> ${today}`);
                const yesterdaysTasks = state.dailyTasks[state.lastDate];
                if (yesterdaysTasks && yesterdaysTasks.length > 0) {
                    // isDeletedでない未完了タスクのみを抽出
                    const leftoverTasks = yesterdaysTasks.filter(t => t.status !== 'completed' && !t.isDeleted);
                    if (leftoverTasks.length > 0) {
                        if (!state.dailyTasks[today]) {
                            state.dailyTasks[today] = [];
                        }
                        state.dailyTasks[today].unshift(...leftoverTasks);
                        // 昨日分のタスクリストからは、持ち越したタスクと完了済みタスク以外（論理削除済みも含む）を更新
                        state.dailyTasks[state.lastDate] = yesterdaysTasks.filter(t => t.status === 'completed' || t.isDeleted);
                    }
                }
                archiveCompletedTasks(state.lastDate);
                // リピートタスクを生成（これは末尾に追加される）
                generateTasksFromRepeatAuto(today);
                state.lastDate = today;
                state.viewDate = today; 
                
                // 先送りタスクとリピートタスクを追加後、セクション順でソートする
                if (state.dailyTasks[today] && state.dailyTasks[today].length > 0) {
                    const sortedSections = [...state.sections].sort((a, b) => a.startTime.localeCompare(b.startTime));
                    const sectionOrder = ['null', ...sortedSections.map(s => s.id)];
                    
                    state.dailyTasks[today].sort((a, b) => {
                        const sectionIndexA = sectionOrder.indexOf(a.sectionId || 'null');
                        const sectionIndexB = sectionOrder.indexOf(b.sectionId || 'null');
                        return sectionIndexA - sectionIndexB;
                    });
                }
                
                // 生成したタスクを画面に反映させる
                const tasksToday = state.dailyTasks[today] || [];
                const firstUncompletedTask = tasksToday.find(t => getTaskStatus(t) !== 'completed');
                if (firstUncompletedTask) {
                    state.focusedTaskId = firstUncompletedTask.id;
                } else if (tasksToday.length > 0) {
                    state.focusedTaskId = tasksToday[tasksToday.length - 1].id;
                } else {
                    state.focusedTaskId = null;
                }
                saveAndRender();
                // Googleカレンダーの予定を非同期で読み込む
                await dailyTaskListApp.importGoogleCalendarEvents(today);
            }
        }

	function archiveCompletedTasks(dateKey) {
        if (!state.dailyTasks[dateKey]) return;
        // isDeletedでない完了タスクのみをアーカイブ対象とする
        const completedTasks = state.dailyTasks[dateKey].filter(t => t.status === 'completed' && !t.isDeleted);
        if (completedTasks.length > 0) {
            if (!state.archivedTasks[dateKey]) {
                state.archivedTasks[dateKey] = [];
            }
            // 既にアーカイブにあるタスクは追加しないようにチェック
            const existingIds = new Set(state.archivedTasks[dateKey].map(t => t.id));
            const newTasksToArchive = completedTasks.filter(t => !existingIds.has(t.id));
            state.archivedTasks[dateKey].push(...newTasksToArchive);
            // isDeletedフラグが立っているタスクか、未完了のタスクのみを残す
            state.dailyTasks[dateKey] = state.dailyTasks[dateKey].filter(t => t.isDeleted || t.status !== 'completed');
        }
    }

    function generateTasksFromRepeatAuto(dateStr) {
        const today = new Date(dateStr);
        today.setMinutes(today.getMinutes() + today.getTimezoneOffset());
        
        const year = today.getFullYear();
        const month = today.getMonth(); // 0-11
        const dayOfMonth = today.getDate();
        const dayOfWeek = today.getDay();

        if (!state.dailyTasks[dateStr]) {
            state.dailyTasks[dateStr] = [];
        }

        state.repeatTasks.forEach(rt => {
            let shouldAdd = false;
            
            switch (rt.type) {
                case 'daily':
                    shouldAdd = true;
                    break;
                case 'weekly':
                    if (Array.isArray(rt.value) && rt.value.includes(dayOfWeek)) {
                        const weekInterval = rt.weekInterval || 1;
                        if (weekInterval === 1) {
                            shouldAdd = true;
                        } else if (rt.startDate) {
                            const start = new Date(rt.startDate);
                            start.setHours(0, 0, 0, 0);
                            const todayCopy = new Date(today);
                            todayCopy.setHours(0, 0, 0, 0);

                            const diffTime = todayCopy.getTime() - start.getTime();
                            if (diffTime >= 0) {
                                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                                const diffWeeks = Math.floor(diffDays / 7);
                                if (diffWeeks % weekInterval === 0) {
                                    shouldAdd = true;
                                }
                            }
                        }
                    }
                    break;
                case 'monthly':
                    if (rt.value) {
                        if (rt.value.type === 'day' && rt.value.day == dayOfMonth) {
                            shouldAdd = true;
                        } else if (rt.value.type === 'weekday') {
                            const targetDay = getNthWeekdayOfMonth(year, month, rt.value.week, rt.value.weekday);
                            if (targetDay && targetDay === dayOfMonth) {
                                shouldAdd = true;
                            }
                        }
                    }
                    break;
                case 'yearly':
                     if (rt.value && rt.value.month == (month + 1) && rt.value.day == dayOfMonth) {
                        shouldAdd = true;
                    }
                    break;
                case 'interval':
                    if (rt.startDate && rt.value > 0) {
                        const start = new Date(rt.startDate);
                        start.setMinutes(start.getMinutes() + start.getTimezoneOffset());
                        const diffTime = today.getTime() - start.getTime();
                        const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
                        if (diffDays >= 0 && diffDays % rt.value === 0) {
                            shouldAdd = true;
                        }
                    }
                    break;
            }

            if (shouldAdd) {
                const isAlreadyAdded = state.dailyTasks[dateStr].some(
                    task => task.originRepeatId === rt.id && task.createdDate === dateStr
                );
                if (!isAlreadyAdded) {
					const newSubtasks = (rt.subtasks || []).map(st => ({...st, completed: false}));
					
                    state.dailyTasks[dateStr].push({
                        id: 't' + Date.now() + Math.random(),
                        name: rt.name,
                        projectId: rt.projectId || null,
						sectionId: rt.sectionId || null,
                        estimatedTime: rt.estimatedTime || 0,
                        actualTime: 0,
                        status: 'pending',
                        isInterrupt: false,
                        memo: rt.memo || '',
						subtasks: newSubtasks,
                        originRepeatId: rt.id,
                        createdDate: dateStr,
                        startTime: null,
                        endTime: null,
                    });
                }
            }
        });
    }

    function generateTasksFromRepeatManual() {
        const todayStr = getFormattedDate(new Date());
        
        if (!state.dailyTasks[todayStr]) {
            state.dailyTasks[todayStr] = [];
        }
        let tasksForToday = state.dailyTasks[todayStr];

        let addedCount = 0;
        const tasksBefore = tasksForToday.length;
        
        generateTasksFromRepeatAuto(todayStr);

        const tasksAfter = state.dailyTasks[todayStr].length;
        addedCount = tasksAfter - tasksBefore;

        if (addedCount > 0) {
            state.focusedTaskId = tasksForToday.length > 0 ? tasksForToday[tasksForToday.length-1].id : null;
            saveAndRender();
            alert(addedCount + ' 件のタスクを生成しました。');
        } else {
            alert('今日生成できるリピートタスクはありません（既に生成済みか該当なし）。');
        }
    }

    function generateSingleRepeatTask(repeatTaskId) {
	    const rt = state.repeatTasks.find(t => t.id === repeatTaskId);
	    if (!rt) return;
	
	    const today = getFormattedDate(new Date());
	    if (!state.dailyTasks[today]) state.dailyTasks[today] = [];
	    
	    // isDeletedでないタスクのみをチェック対象にする
	    const tasksForToday = state.dailyTasks[today].filter(t => !t.isDeleted);
	    
	    const existingTask = tasksForToday.find(t => 
	        t.originRepeatId === repeatTaskId && 
	        t.createdDate === today
	    );
	    
	    if (existingTask) {
	        alert('このリピートタスクは既に今日のタスクとして存在します。');
	        return;
	    }
	    const newSubtasks = (rt.subtasks || []).map(st => ({...st, completed: false}));
	
	    const newTask = {
	        id: 't' + Date.now() + Math.random(),
	        name: rt.name,
	        projectId: rt.projectId || null,
	        sectionId: rt.sectionId || null,
	        estimatedTime: rt.estimatedTime || 0,
	        actualTime: 0,
	        status: 'pending',
	        isInterrupt: false,
	        memo: rt.memo || '',
	        subtasks: newSubtasks,
	        originRepeatId: rt.id,
	        createdDate: today,
	        startTime: null,
	        endTime: null,
	        updatedAt: new Date().toISOString()
	    };
	
	    const allTasks = state.dailyTasks[today]; // isDeletedを含む全タスクで位置を計算
	    const sortedSections = [...state.sections].sort((a, b) => a.startTime.localeCompare(b.startTime));
	    const sectionOrder = ['null', ...sortedSections.map(s => s.id)];
	    const targetSectionId = newTask.sectionId || 'null';
	    const targetSectionOrderIndex = sectionOrder.indexOf(targetSectionId);
	
	    let insertIndex = allTasks.length;
	
	    let lastTaskInTargetSectionIndex = -1;
	    for (let i = allTasks.length - 1; i >= 0; i--) {
	        if ((allTasks[i].sectionId || 'null') === targetSectionId) {
	            lastTaskInTargetSectionIndex = i;
	            break;
	        }
	    }
	
	    if (lastTaskInTargetSectionIndex !== -1) {
	        insertIndex = lastTaskInTargetSectionIndex + 1;
	    } else {
	        let firstTaskInNextSectionIndex = -1;
	        for (let i = 0; i < allTasks.length; i++) {
	            const taskSectionOrderIndex = sectionOrder.indexOf(allTasks[i].sectionId || 'null');
	            if (taskSectionOrderIndex > targetSectionOrderIndex) {
	                firstTaskInNextSectionIndex = i;
	                break;
	            }
	        }
	        if (firstTaskInNextSectionIndex !== -1) {
	            insertIndex = firstTaskInNextSectionIndex;
	        }
	    }
	
	    allTasks.splice(insertIndex, 0, newTask);
	    // setTasksForViewDateは使わず、直接state.dailyTasks[today]を更新する
	
	    state.focusedTaskId = newTask.id;
	    state.viewDate = today;
	    saveAndRender();
	    alert('今日のタスクとして追加しました。');
	}

	function renderSections() {
        const container = document.getElementById('sections-container-list');
        state.sections.sort((a, b) => a.startTime.localeCompare(b.startTime));
        
        container.innerHTML = `<div class="overflow-x-auto">
            <table class="min-w-full bg-white">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="py-2 px-4 border-b text-left">セクション名</th>
                        <th class="py-2 px-4 border-b">操作</th>
                    </tr>
                </thead>
                <tbody id="sections-list-body"></tbody>
            </table>
        </div>`;
        const listBody = document.getElementById('sections-list-body');
        listBody.innerHTML = '';
        state.sections.forEach(section => {
            const { name, range } = getSectionDisplayInfo(section.id);
            const tr = document.createElement('tr');
            tr.className = 'border-b';
            tr.innerHTML = `
                <td class="py-3 px-4">${escapeHtml(name)} <span class="text-gray-500 font-mono text-sm">${range}</span></td>
                <td class="py-3 px-4 text-center space-x-1">
                    <button class="edit-section-btn text-gray-400 hover:text-blue-500 p-1" data-id="${section.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                    </button>
                    <button class="delete-section-btn text-gray-400 hover:text-red-500 p-1" data-id="${section.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg>
                    </button>
                </td>
            `;
            listBody.appendChild(tr);
        });

        document.querySelectorAll('.edit-section-btn').forEach(btn => btn.addEventListener('click', (e) => editSection(e.currentTarget.dataset.id)));
        document.querySelectorAll('.delete-section-btn').forEach(btn => btn.addEventListener('click', (e) => deleteSection(e.currentTarget.dataset.id)));
    }
	
	function addSection() {
	    const nameInput = document.getElementById('section-name');
	    const timeInput = document.getElementById('section-time');
	    const name = nameInput.value.trim();
	    const startTime = timeInput.value;
	
	    if (!name || !startTime) {
	        alert('セクション名と開始時刻を入力してください。');
	        return;
	    }
	
	    state.sections.push({ id: 's' + Date.now(), name, startTime });
	    nameInput.value = '';
	    saveAndRender();
	}
	
	function editSection(id) {
	    const section = state.sections.find(s => s.id === id);
	    if (!section) return;
	
	    const newName = prompt('新しいセクション名を入力してください:', section.name);
	    if (newName === null) return; 
	
	    const newTime = prompt('新しい開始時刻を入力してください (HH:MM):', section.startTime);
	    if (newTime === null) return;
	
	    if (newName.trim()) section.name = newName.trim();
	    if (/^\d{2}:\d{2}$/.test(newTime)) section.startTime = newTime;
	
	    saveAndRender();
	}
	
	function deleteSection(id) {
	    const section = state.sections.find(s => s.id === id);
	    if (!section) return;
	    if (!confirm(`セクション「${section.name}」を削除しますか？\nこのセクションに属するタスクは「セクション無し」に移動します。`)) return;
	
	    // 削除対象セクションに紐づくタスクを「セクション無し」に更新
	    Object.values(state.dailyTasks).flat().forEach(task => {
	        if (task.sectionId === id) task.sectionId = null;
	    });
	    state.repeatTasks.forEach(task => {
	        if (task.sectionId === id) task.sectionId = null;
	    });
	
	    state.sections = state.sections.filter(s => s.id !== id);
	    saveAndRender();
	}

	function getSectionById(id) {
	    return state.sections.find(s => s.id === id);
	}
	
	function getSectionDisplayInfo(sectionId) {
        if (!sectionId || sectionId === 'null') {
            return { name: "セクション無し", range: "" };
        }
        const sortedSections = [...state.sections].sort((a, b) => a.startTime.localeCompare(b.startTime));
        const sectionIndex = sortedSections.findIndex(s => s.id === sectionId);

        if (sectionIndex === -1) {
            return { name: "不明なセクション", range: "" };
        }

        const section = sortedSections[sectionIndex];
        const nextSection = sortedSections[(sectionIndex + 1) % sortedSections.length];
        const endTime = nextSection.startTime;

        return { 
            name: section.name, 
            range: `(${section.startTime}~${endTime})` 
        };
    }
	
	function getCurrentSection() {
	    const now = new Date();
	    const currentTime = now.getHours().toString().padStart(2, '0') + ':' + now.getMinutes().toString().padStart(2, '0');
	
	    // 開始時刻でソートされたセクションリストを使用
	    const sortedSections = [...state.sections].sort((a, b) => a.startTime.localeCompare(b.startTime));
	
	    let currentSection = null;
	    for (const section of sortedSections) {
	        if (section.startTime <= currentTime) {
	            currentSection = section;
	        } else {
	            break; // 現在時刻を超えたらループ終了
	        }
	    }
	    // もしどのセクションにも当てはまらなければ（例: 早朝）、最後のセクションを返す
	    return currentSection || (sortedSections.length > 0 ? sortedSections[sortedSections.length - 1] : null);
	}
	
	function updateSectionDropdowns() {
        const selects = document.querySelectorAll('#new-task-section, #edit-task-section, #repeat-task-section, #edit-repeat-section');
        const sortedSections = [...state.sections].sort((a, b) => a.startTime.localeCompare(b.startTime));

        const optionsHtml = '<option value="">セクション無し</option>' + 
            sortedSections.map(s => {
                const { name, range } = getSectionDisplayInfo(s.id);
                return `<option value="${s.id}">${escapeHtml(name)} ${range}</option>`;
            }).join('');

        selects.forEach(select => {
            const currentValue = select.value;
            select.innerHTML = optionsHtml;
            if (Array.from(select.options).some(opt => opt.value === currentValue)) {
                select.value = currentValue;
            }
        });
    }

    function setupEventListeners() {
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab).classList.add('active');
                
                if (tab.dataset.tab === 'today') {
                    const tasks = getTasksForViewDate();
                    const firstUncompletedTask = tasks.find(t => getTaskStatus(t) !== 'completed');
                    if (firstUncompletedTask) {
                        state.focusedTaskId = firstUncompletedTask.id;
                    } else if (tasks.length > 0) {
                        state.focusedTaskId = tasks[tasks.length - 1].id;
                    } else {
                        state.focusedTaskId = null;
                    }
                } else if (tab.dataset.tab === 'archive') {
                    if (!state.archiveViewDate) {
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        state.archiveViewDate = getFormattedDate(yesterday);
                    }
                }
                render();
            });
        });
        document.querySelector('.tab-link[data-tab="today"]').click();

        document.getElementById('add-project-btn').addEventListener('click', addProject);
		document.getElementById('add-section-btn').addEventListener('click', addSection);
        document.getElementById('add-repeat-task-btn').addEventListener('click', addRepeatTask);
        document.getElementById('generate-from-repeat-btn').addEventListener('click', generateTasksFromRepeatManual);
        
        // --- リピートタスク追加フォームのUI制御 ---
        document.getElementById('repeat-task-type').addEventListener('change', (e) => {
            const value = e.target.value;
            document.getElementById('repeat-weekly-options').classList.toggle('hidden', value !== 'weekly');
            document.getElementById('repeat-monthly-options').classList.toggle('hidden', value !== 'monthly');
            document.getElementById('repeat-yearly-options').classList.toggle('hidden', value !== 'yearly');
            document.getElementById('repeat-interval-options').classList.toggle('hidden', value !== 'interval');
            
            if (value === 'interval' || value === 'weekly') {
                const startDateInput = document.getElementById(value === 'interval' ? 'repeat-interval-start-date' : 'repeat-weekly-start-date');
                if (!startDateInput.value) {
                    startDateInput.value = new Date().toISOString().slice(0, 10);
                }
            }
        });

        document.querySelectorAll('input[name="repeat-monthly-type"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const isDayType = e.target.value === 'day';
                document.getElementById('repeat-monthly-day-options').classList.toggle('hidden', !isDayType);
                document.getElementById('repeat-monthly-weekday-options').classList.toggle('hidden', isDayType);
            });
        });


        document.getElementById('prev-day-btn').addEventListener('click', () => moveViewDate(-1));
        document.getElementById('next-day-btn').addEventListener('click', () => moveViewDate(1));
        document.getElementById('prev-archive-day').addEventListener('click', () => moveArchiveDate(-1));
        document.getElementById('next-archive-day').addEventListener('click', () => moveArchiveDate(1));

        document.querySelectorAll('.archive-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.archive-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                state.archiveView = tab.dataset.view;
                renderArchive();
            });
        });

        document.getElementById('return-to-today-archive').addEventListener('click', () => {
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            state.archiveViewDate = getFormattedDate(yesterday);
            renderArchive();
        });

		document.getElementById('load-gcal-events-btn').addEventListener('click', () => {
        	dailyTaskListApp.importGoogleCalendarEvents(state.viewDate);
    	});

		const searchBtn = document.getElementById('archive-search-btn');
		const searchInput = document.getElementById('archive-search-input');
		const clearBtn = document.getElementById('archive-clear-btn');
		if (searchBtn && searchInput && clearBtn) {
    		searchBtn.addEventListener('click', () => {
        		const q = searchInput.value.trim();
        		renderArchiveSearchView(q);
    		});
    		clearBtn.addEventListener('click', () => {
        		searchInput.value = '';
        		renderArchiveSearchView('');
    		});
    		searchInput.addEventListener('keydown', (e) => {
        		if (e.key === 'Enter') {
            		e.preventDefault();
            		const q = searchInput.value.trim();
            		renderArchiveSearchView(q);
        		}
    		});
		}

        document.getElementById('export-data-btn').addEventListener('click', exportData);
        document.getElementById('import-data-btn').addEventListener('click', importData);
        document.getElementById('clear-data-btn').addEventListener('click', clearAllData);

        setupModalEvents();

		function autoHeightListener(event) {
            // 高さを一度リセットしてからスクロール量に合わせて再設定
            event.target.style.height = 'auto';
            event.target.style.height = (event.target.scrollHeight) + 'px';
        }
        document.getElementById('edit-task-memo').addEventListener('input', autoHeightListener);
        document.getElementById('edit-repeat-memo').addEventListener('input', autoHeightListener);


        document.addEventListener('keydown', handleKeyboardShortcuts);
        
        document.addEventListener('mouseover', (e) => {
            const tooltipContainer = e.target.closest('.tooltip-container');
            if (tooltipContainer) {
                setTimeout(() => positionTooltip(tooltipContainer), 10);
            }
        });
    }

    function setupModalEvents() {
        document.getElementById('save-new-task-btn').addEventListener('click', () => {
             addTask(
                document.getElementById('new-task-name').value,
                document.getElementById('new-task-time').value,
                document.getElementById('new-task-project').value,
				document.getElementById('new-task-section').value
            );
            closeModal('add-task-modal');
        });
        document.getElementById('cancel-add-task-btn').addEventListener('click', () => closeModal('add-task-modal'));
        
        document.getElementById('save-task-edit').addEventListener('click', saveTaskEdit);
        document.getElementById('cancel-task-edit').addEventListener('click', () => closeModal('task-edit-modal'));
        document.getElementById('create-repeat-from-task').addEventListener('click', createRepeatFromTask);

        document.getElementById('edit-memo-text').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                saveMemoEdit();
            }
        });
        document.getElementById('save-memo-edit').addEventListener('click', saveMemoEdit);
        document.getElementById('cancel-memo-edit').addEventListener('click', () => closeModal('memo-edit-modal'));

        document.getElementById('save-repeat-edit').addEventListener('click', saveRepeatEdit);
        document.getElementById('cancel-repeat-edit').addEventListener('click', () => closeModal('repeat-edit-modal'));
        document.getElementById('edit-repeat-type').addEventListener('change', (e) => {
            const value = e.target.value;
            document.getElementById('edit-repeat-weekly-options').classList.toggle('hidden', value !== 'weekly');
            document.getElementById('edit-repeat-monthly-options').classList.toggle('hidden', value !== 'monthly');
            document.getElementById('edit-repeat-yearly-options').classList.toggle('hidden', value !== 'yearly');
            document.getElementById('edit-repeat-interval-options').classList.toggle('hidden', value !== 'interval');
             if (value === 'interval') {
                const startDateInput = document.getElementById('edit-repeat-interval-start-date');
                if (!startDateInput.value) {
                    startDateInput.value = new Date().toISOString().slice(0, 10);
                }
            }
        });
		
        document.getElementById('new-task-name').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (document.getElementById('new-task-name').value.trim() === '') {
                    closeModal('add-task-modal');
                } else {
                    document.getElementById('save-new-task-btn').click();
                }
            }
        });

        document.getElementById('edit-task-name').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); saveTaskEdit(); }
        });

        document.getElementById('edit-repeat-name').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); saveRepeatEdit(); }
        });

        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal(modal.id);
            });
        });
    }

    function openModal(modalId) {
        document.getElementById(modalId).classList.add('active');
		renderFloatingTaskBar();
    }

    function closeModal(modalId) {
        document.getElementById(modalId).classList.remove('active');
        if (modalId === 'task-edit-modal') {
            state.editingTaskDateKey = null;
            state.editingTaskId = null;
        }
		renderFloatingTaskBar();
    }

    function render(options = {}) {
        const activeTab = document.querySelector('.tab-link.active').dataset.tab;
        if (activeTab === 'today') renderTodayTasks(options);
        else if (activeTab === 'repeat') renderRepeatTasks();
		else if (activeTab === 'sections') renderSections();
        else if (activeTab === 'projects') renderProjects();
        else if (activeTab === 'archive') renderArchive();
        updateProjectDropdowns();
		updateSectionDropdowns();
        calculateAllEstimates();
		updateTitle();
		renderFloatingTaskBar();
    }

    function renderTodayTasks(options = {}) {
            const container = document.getElementById('sections-container');
            container.innerHTML = '';
            
            const viewDateObj = new Date(state.viewDate);
            const todayStr = getFormattedDate(new Date());

            const limitDate = new Date();
            limitDate.setDate(limitDate.getDate() + 2);
            const limitDateStr = getFormattedDate(limitDate);

            let dateLabel = viewDateObj.toLocaleDateString('ja-JP', { month: 'long', day: 'numeric', weekday: 'short' });

            document.getElementById('view-date-display').textContent = dateLabel;

            const prevBtn = document.getElementById('prev-day-btn');
            prevBtn.style.visibility = (state.viewDate <= todayStr) ? 'hidden' : 'visible';

            const nextBtn = document.getElementById('next-day-btn');
            nextBtn.style.visibility = (state.viewDate >= limitDateStr) ? 'hidden' : 'visible';

            const tasks = getTasksForViewDate();
            if (tasks.length === 0 && state.sections.every(s => s.id !== 'null')) {
                container.innerHTML = `<p class="text-center text-gray-500 py-8">タスクはありません。[N]キーで追加できます。</p>`;
            }


            const sortedSections = [...state.sections].sort((a, b) => a.startTime.localeCompare(b.startTime));
            const tasksBySection = { 'null': [] }; 
            sortedSections.forEach(s => tasksBySection[s.id] = []);

            tasks.forEach(task => {
                const sectionId = task.sectionId || 'null';
                if (tasksBySection.hasOwnProperty(sectionId)) {
                    tasksBySection[sectionId].push(task);
                } else {
                    tasksBySection['null'].push(task); 
                }
            });
            
            const sectionOrder = ['null', ...sortedSections.map(s => s.id)];

            if (isMobile()) {
                const wrapper = document.createElement('div');
                wrapper.className = 'task-card-wrapper';
                sectionOrder.forEach(sectionId => {
                    const sectionTasks = tasksBySection[sectionId];
                    if (sectionId === 'null' && sectionTasks.length === 0) return;
            
                    const { name, range } = getSectionDisplayInfo(sectionId);
                    
                    // セクション毎の残り時間を計算
                    const remainingTimeInSection = sectionTasks
                        .filter(task => getTaskStatus(task) !== 'completed')
                        .reduce((sum, task) => sum + (task.estimatedTime || 0), 0);
                    const remainingTimeHtml = remainingTimeInSection > 0 ? `<span>見積: ${remainingTimeInSection}分</span>` : '';

                    const sectionHeader = document.createElement('div');
                    sectionHeader.className = 'text-xs font-bold text-white mt-2 px-2 py-1 bg-gray-500 flex justify-between items-center';
                    sectionHeader.innerHTML = `<span>${name} ${range}</span> ${remainingTimeHtml}`;
                    wrapper.appendChild(sectionHeader);
            
                    renderTaskCards(wrapper, sectionTasks);
                    
                    if (sectionTasks.length === 0) {
                        const dropTarget = document.createElement('div');
                        dropTarget.className = 'empty-section-drop-target text-center text-gray-400 text-xs border-dashed border-gray-300 rounded-lg';
                        dropTarget.textContent = 'ここにタスクをドロップ';
                        dropTarget.dataset.sectionId = sectionId;
                        wrapper.appendChild(dropTarget);
                    }
                });
                container.appendChild(wrapper);
            } else {
                const wrapper = document.createElement('div');
                wrapper.className = 'bg-white shadow-md';
                const tableContainer = document.createElement('div');
                tableContainer.className = 'overflow-x-auto';
                const table = document.createElement('table');
                table.className = 'min-w-full task-table';
                table.innerHTML = `
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-8"></th>
                            <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-8"></th>
                            <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider">タスク</th>
                            <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-20">見積</th>
                            <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-20">実績</th>
                            <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-20">開始</th>
                            <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-20">終了</th>
                            <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-28">操作</th>
                        </tr>
                    </thead>
                    <tbody id="task-table-body"></tbody>
                `;
                const tbody = table.querySelector('tbody');
                
                const visibleSections = sectionOrder.filter(id => !(id === 'null' && tasksBySection[id].length === 0));
                const lastVisibleSectionId = visibleSections.length > 0 ? visibleSections[visibleSections.length - 1] : null;

                visibleSections.forEach(sectionId => {
                    const sectionTasks = tasksBySection[sectionId];
                    
                    const { name, range } = getSectionDisplayInfo(sectionId);

                    // セクション毎の残り時間を計算
                    const remainingTimeInSection = sectionTasks
                        .filter(task => getTaskStatus(task) !== 'completed')
                        .reduce((sum, task) => sum + (task.estimatedTime || 0), 0);
                    const remainingTimeHtml = remainingTimeInSection > 0 ? `<span>見積: ${remainingTimeInSection}分</span>` : '';

                    const headerRow = document.createElement('tr');
                    headerRow.className = 'bg-gray-100';
                    headerRow.dataset.sectionId = sectionId;
                    headerRow.innerHTML = `
                        <td colspan="8" class="py-1 px-4 text-xs font-bold text-white bg-gray-400">
                            <div class="justify-between items-center">
                                <span>${name} ${range}</span>
                                ${remainingTimeHtml}
                            </div>
                        </td>`;
                    tbody.appendChild(headerRow);
                    
                    renderTaskTable(tbody, sectionTasks, { isLast: sectionId === lastVisibleSectionId });
                });
    
                tableContainer.appendChild(table);
                wrapper.appendChild(tableContainer);
                container.appendChild(wrapper);
            }

            attachTaskEventListeners();
            setupDragAndDrop('.task-row, .task-card', tasks); 
            
            const focusedEl = document.querySelector('.task-row.focused, .task-card.focused');
            if (focusedEl && !options.noScroll) {
                focusedEl.scrollIntoView({ block:'nearest', behavior:'smooth' });
            }
        }

	function renderTaskTable(tbody, tasksToRender, options = {}) {
	    if (tasksToRender.length === 0) {
	        const parentHeader = tbody.lastElementChild;
	        if (parentHeader && parentHeader.dataset.sectionId) {
	             const tr = document.createElement('tr');
	             tr.className = 'empty-section-drop-target';
	             tr.dataset.sectionId = parentHeader.dataset.sectionId;
	             tr.innerHTML = `<td colspan="8" class="px-4 text-center text-gray-400 text-xs">ここにタスクをドロップできます</td>`;
	             tbody.appendChild(tr);
	        }
	        return;
	    }
	
	    tasksToRender.forEach(task => {
	        const allTasks = getTasksForViewDate();
	        const index = allTasks.findIndex(t => t.id === task.id);
	        const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
	        const tr = document.createElement('tr');
	        tr.className = `border-b task-row ${task.status === 'completed' ? 'bg-gray-100 text-gray-500' : ''} ${task.status === 'running' ? 'bg-blue-50' : ''} ${task.id === state.focusedTaskId ? 'focused' : ''}`;
	        tr.dataset.taskId = task.id;
	        tr.dataset.index = index;
	        tr.dataset.sectionId = task.sectionId || 'null';
	        tr.draggable = true;
	
	        const isRunning = task.status === 'running';
	        const isCompleted = task.status === 'completed';
	
	        let timerButtonHtml = '';
	        if(isCompleted) {
	            timerButtonHtml = `
	            <button class="timer-btn checkmark-btn cursor-pointer items-center justify-center">
	                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-600" viewBox="0 0 19 19" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
	            </button>`;
	        } else {
	             timerButtonHtml = `<button class="timer-btn transition-colors duration-200 ${isRunning ? 'text-red-500 hover:text-red-600' : 'text-green-500 hover:text-green-600'}">
	                ${isRunning ? '■' : '▶'}
	            </button>`;
	        }
	        
	        const subtasks = task.subtasks || [];
	        let subtaskIconHtml = '';
	        if (subtasks.length > 0) {
	            subtaskIconHtml = `
	            <span class="subtask-toggle-icon" data-task-id="${task.id}" title="サブタスク (S)">
	                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mb-0.5" viewBox="0 0 20 20" fill="currentColor">
	                    <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" />
	                    <path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd" />
	                </svg>
	            </span>`;
	        }
	
	        const memoIcon = task.memo ? `
	            <span class="tooltip-container memo-icon-clickable" data-task-id="${task.id}">
	                 <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block mb-1 ml-1 text-gray-400 cursor-pointer hover:text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
	                <span class="custom-tooltip">${escapeHtml(task.memo)}</span>
	            </span>` : '';
	        
	        const actualTimeDisplay = `<span class="font-mono time-actual">${formatTime(calculateActualTime(task))}</span>`;
	
	        const todayStr = getFormattedDate(new Date());
	        const isFutureDate = state.viewDate > todayStr;
	        let moveButtonHtml = '';
	        if (isFutureDate) {
	            moveButtonHtml = `
	            <button class="move-to-today-btn text-gray-400 hover:text-green-500 p-1" title="当日に移動">
	                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" /></svg>
	            </button>`;
	        } else {
	            moveButtonHtml = `
	            <button class="postpone-task-btn text-gray-400 hover:text-yellow-500 p-1" title="翌日に先送り (P)">
	                 <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 9l3 3m0 0l-3 3m3-3H8m13 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
	            </button>`;
	        }
	
	        tr.innerHTML = `
	            <td class="text-center"><span class="drag-handle">⋮⋮</span></td>
	            <td class="text-center">${timerButtonHtml}</td>
	            <td>
	                <div class="flex items-center justify-between">
	                    <div class="flex items-center space-x-1 min-w-0">
	                        <span class="inline-block w-2 h-2 rounded-full flex-shrink-0" style="background-color: ${project.color};"></span>
	                        <span class="pl-1 font-semibold text-sm truncate" title="${escapeHtml(task.name || '')}">${formatTaskName(task.name)}</span>
	                        ${subtaskIconHtml} ${memoIcon}
	                    </div>
	                    <span class="text-xs text-gray-400 ml-2 whitespace-nowrap flex-shrink-0 project-label">${escapeHtml(project.name)}</span>
	                </div>
	            </td>
	            <td class="text-center text-sm whitespace-nowrap">${task.estimatedTime || 0} 分</td>
	            <td class="text-center text-sm whitespace-nowrap">${actualTimeDisplay}</td>
	            <td class="text-center text-sm whitespace-nowrap font-mono">${task.startTime ? formatClockTime(new Date(task.startTime)) : '--:--'}</td>
	            <td class="text-center text-sm whitespace-nowrap font-mono">${task.endTime ? formatClockTime(new Date(task.endTime)) : '--:--'}</td>
	            <td class="text-center space-x-1">
	                <button class="edit-task-btn text-gray-400 hover:text-blue-500 p-1" title="編集 (E)">
	                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
	                </button>
	                ${moveButtonHtml}
	                <button class="delete-task-btn text-gray-400 hover:text-red-500 p-1" title="削除 (D)">
	                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16"></path></svg>
	                </button>
	            </td>
	        `;
	        tbody.appendChild(tr);
	
	        if (subtasks.length > 0) {
	            const subtaskTr = document.createElement('tr');
	            subtaskTr.className = 'subtask-container-row';
	            subtaskTr.dataset.parentTaskId = task.id;
	            
	            const subtaskTd = document.createElement('td');
	            subtaskTd.colSpan = 8;
	            
	            const subtaskContainer = document.createElement('div');
	            subtaskContainer.id = `subtasks-${task.id}`;
	            subtaskContainer.className = `subtask-container ${state.openTaskIds.has(task.id) ? 'open' : ''}`;
	            
	            subtasks.forEach(st => {
	                const item = document.createElement('div');
	                item.className = `subtask-item ${st.completed ? 'completed' : ''} ${st.id === state.focusedSubtaskId ? 'focused' : ''}`;
	                item.innerHTML = `
	                    <input type="checkbox" class="subtask-checkbox form-checkbox h-4 w-4 text-blue-600" data-subtask-id="${st.id}" ${st.completed ? 'checked' : ''}>
	                    <span class="ml-3 text-sm flex-1">${formatTaskName(st.name)}</span>
	                `;
	                item.addEventListener('click', (e) => {
	                    if (e.target.matches('.subtask-checkbox')) {
	                        return;
	                    }
	                    e.stopPropagation();
	                    state.focusedTaskId = task.id;
	                    state.focusedSubtaskId = st.id;
	                    render();
	                });
	                item.addEventListener('dblclick', (e) => {
	                    e.preventDefault();
	                    toggleSubtaskCompletion(task.id, st.id, !st.completed);
	                });
	                subtaskContainer.appendChild(item);
	            });
	            
	            subtaskTd.appendChild(subtaskContainer);
	            subtaskTr.appendChild(subtaskTd);
	            tbody.appendChild(subtaskTr);
	        }
	    });
	}

	function renderTaskCards(wrapper, tasksToRender) {
        tasksToRender.forEach(task => {
            const allTasks = getTasksForViewDate();
            const index = allTasks.findIndex(t => t.id === task.id);
            const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
            const cardWrapper = document.createElement('div');
            const card = document.createElement('div');
            const isCompleted = task.status === 'completed';
            card.className = `task-card bg-white px-3 py-2 mt-2 shadow border-l-4 ${isCompleted ? 'completed' : ''} ${task.status === 'running' ? 'bg-blue-50' : ''} ${task.id === state.focusedTaskId ? 'focused' : ''}`;
            card.style.borderLeftColor = project.color;
            card.dataset.taskId = task.id;
            card.dataset.index = index;
            card.dataset.sectionId = task.sectionId || 'null';
            card.draggable = true;

            const isRunning = task.status === 'running';
            let timerButtonHtml = '';
            if (isCompleted) {
                 timerButtonHtml = `
                 <button class="timer-btn checkmark-btn rounded-full bg-gray-200 hover:bg-gray-300 cursor-pointer items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-600" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
                </button>`;
            } else {
                timerButtonHtml = `<button class="timer-btn transition-colors duration-200 flex-shrink-0 ${isRunning ? 'text-red-500 hover:text-red-600' : 'text-green-500 hover:text-green-600'}">
                    ${isRunning ? '■' : '▶'}
                </button>`;
            }

            const subtasks = task.subtasks || [];
            let subtaskIconHtml = '';
            if (subtasks.length > 0) {
                subtaskIconHtml = `
                <span class="subtask-toggle-icon ml-1" data-task-id="${task.id}" title="サブタスク (S)">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" /><path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd" /></svg>
                </span>`;
            }

            const memoIcon = task.memo ? `
                 <span class="tooltip-container memo-icon-clickable" data-task-id="${task.id}">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block ml-1 mb-0.5 text-gray-400 cursor-pointer hover:text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                    <span class="custom-tooltip">${escapeHtml(task.memo)}</span>
                </span>` : '';
			
			const actualTimeHtml = isCompleted ? `<span class="text-gray-600">実績: ${formatTime(calculateActualTime(task))}</span>` : '';

            const todayStr = getFormattedDate(new Date());
            const isFutureDate = state.viewDate > todayStr;
            let moveButtonHtml = '';
            if (isFutureDate) {
                moveButtonHtml = `
                <button class="move-to-today-btn text-gray-400 hover:text-green-500 p-1">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" /></svg>
                </button>`;
            } else {
                moveButtonHtml = `
                <button class="postpone-task-btn text-gray-400 hover:text-yellow-500 p-1">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 9l3 3m0 0l-3 3m3-3H8m13 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                </button>`;
            }

            card.innerHTML = `
                <div class="flex items-center gap-3">
                    <div class="flex flex-col items-center">
                        ${timerButtonHtml}
                    </div>
                    <div class="flex-1 min-w-0">
                        <div class="flex justify-between items-start">
                             <h3 class="font-semibold text-base truncate flex items-center pr-2" title="${escapeHtml(task.name || '')}">
                               ${formatTaskName(task.name)}
                               ${subtaskIconHtml} ${memoIcon}
                            </h3>
                             <div class="flex space-x-1 flex-shrink-0">
                                <button class="edit-task-btn text-gray-400 hover:text-blue-500 p-1">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                                </button>
                                ${moveButtonHtml}
                                <button class="delete-task-btn text-gray-400 hover:text-red-500 p-1">
								    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16"></path></svg>
								</button>
                            </div>
                        </div>
                        <div class="flex items-center justify-between text-xs text-gray-600 mt-1">
                            <div class="flex items-center space-x-3">
								<div class="min-w-20">
                                    <span>見積: ${task.estimatedTime || 0}分</span>
                                </div>
								${actualTimeHtml}
                            </div>
                            <div class="font-mono text-gray-400">
                                ${task.startTime ? formatClockTime(new Date(task.startTime)) : ''}
                                ${task.endTime ? ' - ' + formatClockTime(new Date(task.endTime)) : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            cardWrapper.appendChild(card);
            
            if (subtasks.length > 0) {
                const subtaskContainer = document.createElement('div');
                subtaskContainer.id = `subtasks-${task.id}`;
                subtaskContainer.className = `subtask-container ${state.openTaskIds.has(task.id) ? 'open' : ''}`;
                subtasks.forEach(st => {
                    const item = document.createElement('div');
                    item.className = `subtask-item ${st.completed ? 'completed' : ''} ${st.id === state.focusedSubtaskId ? 'focused' : ''}`;
                    item.innerHTML = `
                        <input type="checkbox" class="subtask-checkbox form-checkbox h-4 w-4 text-blue-600" data-subtask-id="${st.id}" ${st.completed ? 'checked' : ''}>
                        <span class="ml-3 flex-1">${formatTaskName(st.name)}</span>
                    `;
                    item.addEventListener('click', (e) => {
						if (e.target.matches('.subtask-checkbox')) {
                            return;
                        }
                        e.stopPropagation();
                        state.focusedTaskId = task.id;
                        state.focusedSubtaskId = st.id;
                        render();
                    });
					item.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        toggleSubtaskCompletion(task.id, st.id, !st.completed);
                    });
                    subtaskContainer.appendChild(item);
                });
                cardWrapper.appendChild(subtaskContainer);
            }
            wrapper.appendChild(cardWrapper);
        });
    }

    function renderArchive() {
        const dateView = document.getElementById('archive-date-view');
        const searchView = document.getElementById('archive-search-view');
        
        dateView.classList.toggle('hidden', state.archiveView !== 'date');
        searchView.classList.toggle('hidden', state.archiveView !== 'search');

        if (state.archiveView === 'date') {
            renderArchiveDateView();
        } else if (state.archiveView === 'search') {
			const q = document.getElementById('archive-search-input').value.trim();
			renderArchiveSearchView(q);
		}
    }

    function renderArchiveDateView() {
        const dateEl = document.getElementById('archive-date');
        const listEl = document.getElementById('archive-tasks-list');
        const nextBtn = document.getElementById('next-archive-day');
        const returnBtn = document.getElementById('return-to-today-archive');

        const dateObj = new Date(state.archiveViewDate);
        const year = dateObj.getFullYear();
        const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
        const day = dateObj.getDate().toString().padStart(2, '0');
        const weekday = dateObj.toLocaleDateString('ja-JP', { weekday: 'short' });
        dateEl.textContent = `${year}年${month}月${day}日(${weekday})`;
        
        const tasksForDay = state.archivedTasks[state.archiveViewDate] || [];

        const tomorrow = new Date();
        nextBtn.disabled = state.archiveViewDate === getFormattedDate(tomorrow);
        nextBtn.classList.toggle('opacity-50', nextBtn.disabled);

        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayStr = getFormattedDate(yesterday);
        returnBtn.classList.toggle('hidden', state.archiveViewDate === yesterdayStr);

        if (tasksForDay.length === 0) {
            listEl.innerHTML = '<p class="text-center text-gray-500 py-8">この日に完了したタスクはありません。</p>';
            return;
        }

        let tableHtml = '<table class="min-w-full bg-white">';
        tableHtml += `<thead class="bg-gray-50">
                    <tr>
                        <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">タスク</th>
                        <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-20">実績時間</th>
                        <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">開始</th>
                        <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">終了</th>
                        <th class="py-2 px-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-24">操作</th>
                    </tr>
                 </thead><tbody>`;

        tasksForDay.forEach(task => {
            const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
            const memoHtml = task.memo ? `<p class="text-xs text-gray-500 mt-1 whitespace-pre-wrap pl-4">${escapeHtml(task.memo)}</p>` : '';
            tableHtml += `
                <tr class="border-b">
                    <td class="py-2 px-3 task-memo-cell">
                        <div class="flex items-center space-x-2">
                           <span class="inline-block w-2 h-2 rounded-full flex-shrink-0" style="background-color: ${project.color};"></span>
                           <div>
                             <span class="font-semibold">${formatTaskName(task.name)}</span>
                             <span class="text-xs text-gray-400 ml-2">${escapeHtml(project.name)}</span>
                           </div>
                        </div>
                        ${memoHtml}
                    </td>
                    <td class="py-2 px-3 text-sm font-mono whitespace-nowrap">
                         ${formatTime(calculateActualTime(task))}
                    </td>
                    <td class="py-2 px-3 text-sm font-mono whitespace-nowrap">${task.startTime ? formatClockTime(new Date(task.startTime)) : '--:--'}</td>
                    <td class="py-2 px-3 text-sm font-mono whitespace-nowrap">${task.endTime ? formatClockTime(new Date(task.endTime)) : '--:--'}</td>
                    <td class="py-2 px-3 text-center space-x-1">
                        <button class="edit-archived-task-btn text-gray-400 hover:text-blue-500 p-1" data-task-id="${task.id}" data-date-key="${state.archiveViewDate}" title="編集">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                        </button>
                        <button class="delete-archived-task-btn text-gray-400 hover:text-red-500 p-1" data-task-id="${task.id}" data-date-key="${state.archiveViewDate}" title="削除">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                    </td>
                </tr>
            `;
        });

        tableHtml += '</tbody></table>';
        listEl.innerHTML = `<div class="archive-table-wrapper">${tableHtml}</div>`;
        attachArchiveEventListeners();
    }

    function renderArchiveSearchView(query) {
        const container = document.getElementById('archive-search-results');
        const q = (query || '').trim();
        if (!q) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">検索語を入力して「検索」ボタンを押してください。</p>`;
            return;
        }

        const normalized = q.toLowerCase();
        const results = [];

        Object.entries(state.archivedTasks).forEach(([dateKey, tasks]) => {
            tasks.forEach(task => {
                const name = (task.name || '').toLowerCase();
                const memo = (task.memo || '').toLowerCase();
                if (name.includes(normalized) || memo.includes(normalized)) {
                    results.push({ date: dateKey, task });
                }
            });
        });

        if (results.length === 0) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">「${escapeHtml(q)}」に一致するアーカイブ済みタスクは見つかりませんでした。</p>`;
            return;
        }

        results.sort((a, b) => (a.date < b.date ? 1 : a.date > b.date ? -1 : 0));

        let tableHtml = '<table class="min-w-full bg-white"><thead class="bg-gray-50"><tr>';
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">完了日</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">タスク</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">プロジェクト</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">実績時間</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">開始</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">終了</th>`;
        tableHtml += `</tr></thead><tbody>`;

        results.forEach(({ date, task }) => {
            const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
            const memoHtml = task.memo ? `<div class="text-xs text-gray-500 mt-1 whitespace-pre-wrap">${escapeHtml(task.memo)}</div>` : '';
            const dateLabel = new Date(date).toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', weekday: 'short' });

            tableHtml += `<tr class="border-b">`;
            tableHtml += `<td class="py-2 px-3">${dateLabel}</td>`;
            tableHtml += `<td class="py-2 px-3 task-memo-cell">${formatTaskName(task.name)}${memoHtml}</td>`;
            tableHtml += `<td class="py-2 px-3">${escapeHtml(project.name)}</td>`;
            tableHtml += `<td class="py-2 px-3 font-mono">${formatTime(calculateActualTime(task))}</td>`;
            tableHtml += `<td class="py-2 px-3 font-mono">${task.startTime ? formatClockTime(new Date(task.startTime)) : '--:--'}</td>`;
            tableHtml += `<td class="py-2 px-3 font-mono">${task.endTime ? formatClockTime(new Date(task.endTime)) : '--:--'}</td>`;
            tableHtml += `</tr>`;
        });

        tableHtml += '</tbody></table>';
        container.innerHTML = `<div class="archive-table-wrapper">${tableHtml}</div>`;
    }

    function attachTaskEventListeners() {
        document.querySelectorAll('.task-row, .task-card').forEach(el => {
            el.addEventListener('click', (e) => {
                if (e.target.closest('button, a, .memo-icon-clickable, .subtask-toggle-icon, .subtask-checkbox')) {
                    return;
                }
                const taskId = e.currentTarget.dataset.taskId;
                if (state.focusedTaskId !== taskId || state.focusedSubtaskId !== null) {
                    state.focusedTaskId = taskId;
                    state.focusedSubtaskId = null;
                    renderTodayTasks();
                }
            });

            el.addEventListener('dblclick', (e) => {
                if (e.target.closest('button, a, input, .drag-handle')) {
                    return;
                }
                e.preventDefault(); // ダブルクリックによるテキスト選択を防止
                const taskId = e.currentTarget.dataset.taskId;
                if (taskId) {
                    openMemoEditModal(taskId);
                }
            });
        });

        document.querySelectorAll('.timer-btn, .checkmark-btn').forEach(btn => 
            btn.addEventListener('click', (e) => toggleTimer(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        document.querySelectorAll('.delete-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => deleteTask(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        document.querySelectorAll('.postpone-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => postponeTask(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        document.querySelectorAll('.move-to-today-btn').forEach(btn => 
            btn.addEventListener('click', (e) => moveTaskToToday(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        document.querySelectorAll('.edit-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => openTaskEditModal(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        
        document.querySelectorAll('.memo-icon-clickable').forEach(icon => 
            icon.addEventListener('click', (e) => {
                e.stopPropagation();
                openMemoEditModal(e.currentTarget.dataset.taskId);
            })
        );
        
        document.querySelectorAll('.subtask-toggle-icon').forEach(icon => {
            icon.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleSubtaskView(e.currentTarget.dataset.taskId);
            });
        });
        
        document.querySelectorAll('.subtask-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                const subtaskId = e.target.dataset.subtaskId;
                const subtaskRow = e.target.closest('[data-parent-task-id]');
                const cardWrapper = e.target.closest('.task-card-wrapper > div');
                let taskId = null;
                if (subtaskRow) {
                    taskId = subtaskRow.dataset.parentTaskId;
                } else if (cardWrapper) {
                    const card = cardWrapper.querySelector('[data-task-id]');
                    if(card) taskId = card.dataset.taskId;
                }
                if(taskId) {
                    toggleSubtaskCompletion(taskId, subtaskId, e.target.checked);
                } else {
                    console.error("Could not find parent task ID for subtask.");
                }
            });
        });
    }

    function attachArchiveEventListeners() {
        document.querySelectorAll('.edit-archived-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => openArchivedTaskEditModal(e.currentTarget.dataset.dateKey, e.currentTarget.dataset.taskId))
        );
        document.querySelectorAll('.delete-archived-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => deleteArchivedTask(e.currentTarget.dataset.dateKey, e.currentTarget.dataset.taskId))
        );
    }
    
	function setupDragAndDrop(selector, list, type = 'daily') {
	    let draggedIndex = null;
	    let isDragging = false;
	
	    // ドラッグ開始時にクラスを追加
	    function addDraggingClass() {
	        if (!isDragging) {
	            isDragging = true;
	            document.body.classList.add('dragging-active');
	            // 少し遅延させてから要素を再取得してイベントリスナーを追加
	            setTimeout(() => {
	                attachDropTargetListeners();
	            }, 50);
	        }
	    }
	
	    // ドラッグ終了時にクラスを削除
	    function removeDraggingClass() {
	        if (isDragging) {
	            isDragging = false;
	            document.body.classList.remove('dragging-active');
	        }
	    }
	
	    // 空のドロップターゲットにイベントリスナーを追加
	    function attachDropTargetListeners() {
	        const emptyTargets = document.querySelectorAll('.empty-section-drop-target');
	        emptyTargets.forEach(el => {
	            if (el.dataset.listenersAttached) return;
	            el.dataset.listenersAttached = 'true';
	            
	            el.addEventListener('dragover', handleDragOver);
	            el.addEventListener('dragleave', handleDragLeave);
	            el.addEventListener('drop', handleDrop);
	        });
	    }
	
	    function handleDragOver(e) {
	        e.preventDefault();
	        const target = e.target.closest(selector + ', .empty-section-drop-target');
	        if (target) {
	            const targetIndex = target.dataset.index ? parseInt(target.dataset.index, 10) : -1;
	            if (targetIndex !== draggedIndex) {
	                document.querySelectorAll('.drag-over').forEach(item => item.classList.remove('drag-over'));
	                target.classList.add('drag-over');
	            }
	        }
	    }
	
	    function handleDragLeave(e) {
	        e.target.closest(selector + ', .empty-section-drop-target')?.classList.remove('drag-over');
	    }
	
	    function handleDrop(e) {
	        e.preventDefault();
	        const target = e.target.closest(selector + ', .empty-section-drop-target');
	        if (!target) return;
	        target.classList.remove('drag-over');
	
	        const fromIndex = draggedIndex;
	        if (fromIndex === null) return;
	
	        const movedItem = list.splice(fromIndex, 1)[0];
	
	        if (target.classList.contains('empty-section-drop-target')) {
	            const targetSectionId = target.dataset.sectionId;
	            movedItem.sectionId = (targetSectionId === 'null') ? null : targetSectionId;
	
	            const sortedSections = [...state.sections].sort((a, b) => a.startTime.localeCompare(b.startTime));
	            const sectionOrder = ['null', ...sortedSections.map(s => s.id)];
	            const targetSectionOrderIndex = sectionOrder.indexOf(targetSectionId);
	            
	            let insertIndex = list.length;
	            let firstTaskInNextSectionIndex = -1;
	
	            for (let i = 0; i < list.length; i++) {
	                const taskSectionOrderIndex = sectionOrder.indexOf(list[i].sectionId || 'null');
	                if (taskSectionOrderIndex > targetSectionOrderIndex) {
	                    firstTaskInNextSectionIndex = i;
	                    break;
	                }
	            }
	            if (firstTaskInNextSectionIndex !== -1) {
	                insertIndex = firstTaskInNextSectionIndex;
	            }
	            list.splice(insertIndex, 0, movedItem);
	
	        } else {
	            const toIndex = parseInt(target.dataset.index, 10);
	            const targetSectionId = target.dataset.sectionId;
	            if (targetSectionId && movedItem.sectionId !== targetSectionId) {
	                movedItem.sectionId = (targetSectionId === 'null') ? null : targetSectionId;
	            }
	            list.splice(toIndex, 0, movedItem);
	        }
	
	        if (type === 'daily') {
	            setTasksForViewDate(list);
	        } else if (type === 'repeat') {
	            state.repeatTasks = list;
	        } else if (type === 'project') {
	            state.projects = list;
	        }
	        
	        removeDraggingClass();
	        saveAndRender({ noScroll: true });
	    }
	
	    // 通常のタスク要素にイベントリスナーを追加
	    const elements = document.querySelectorAll(selector);
	    elements.forEach(el => {
	        el.addEventListener('dragstart', (e) => {
	            draggedIndex = parseInt(el.dataset.index, 10);
	            e.dataTransfer.setData('text/plain', draggedIndex);
	
	            const rect = el.getBoundingClientRect();
	
	            const pointerX = (typeof e.clientX === 'number') ? e.clientX : (rect.left + rect.width / 2);
	            const pointerY = (typeof e.clientY === 'number') ? e.clientY : (rect.top + rect.height / 2);
	            let offsetX = Math.round(pointerX - rect.left);
	            let offsetY = Math.round(pointerY - rect.top);
	
	            const dragImage = el.cloneNode(true);
	            dragImage.style.position = 'absolute';
	            dragImage.style.top = '-9999px';
	            dragImage.style.left = '-9999px';
	            dragImage.style.width = el.offsetWidth + 'px';
	            dragImage.style.boxSizing = 'border-box';
	            dragImage.style.background = '#ffffff';
	
	            const originalCells = el.querySelectorAll('td, th');
	            const clonedCells = dragImage.querySelectorAll('td, th');
	            originalCells.forEach((cell, index) => {
	                if (clonedCells[index]) {
	                    clonedCells[index].style.width = cell.offsetWidth + 'px';
	                    clonedCells[index].style.minWidth = cell.offsetWidth + 'px';
	                    clonedCells[index].style.maxWidth = cell.offsetWidth + 'px';
	                    clonedCells[index].style.boxSizing = 'border-box';
	                }
	            });
	
	            dragImage.querySelectorAll('.custom-tooltip').forEach(tip => tip.remove());
	            document.body.appendChild(dragImage);
	
	            const imgWidth = dragImage.offsetWidth || rect.width;
	            const imgHeight = dragImage.offsetHeight || rect.height;
	
	            if (offsetX < 0) offsetX = 0;
	            if (offsetY < 0) offsetY = 0;
	            if (offsetX > imgWidth) offsetX = imgWidth;
	            if (offsetY > imgHeight) offsetY = imgHeight;
	
	            try {
	                e.dataTransfer.setDragImage(dragImage, offsetX, offsetY);
	            } catch (err) {
	                e.dataTransfer.setDragImage(dragImage, 0, 0);
	            }
	
	            setTimeout(() => {
	                el.classList.add('dragging');
	                addDraggingClass();
	                if (dragImage.parentElement) document.body.removeChild(dragImage);
	            }, 0);
	        });
	
	        el.addEventListener('dragend', () => {
	            el.classList.remove('dragging');
	            draggedIndex = null;
	            removeDraggingClass();
	            document.querySelectorAll('.drag-over').forEach(item => item.classList.remove('drag-over'));
	            
	            // リスナーのフラグをリセット
	            document.querySelectorAll('.empty-section-drop-target').forEach(target => {
	                delete target.dataset.listenersAttached;
	            });
	        });
	
	        el.addEventListener('dragover', handleDragOver);
	        el.addEventListener('dragleave', handleDragLeave);
	        el.addEventListener('drop', handleDrop);
	    });
	}

	function openAddTaskModal() {
	    document.getElementById('new-task-name').value = '';
	    document.getElementById('new-task-time').value = '5';
	    document.getElementById('new-task-project').value = '';
	
	    // 現在のセクションをデフォルトで選択
	    const currentSection = getCurrentSection();
	    document.getElementById('new-task-section').value = currentSection ? currentSection.id : '';
	
	    openModal('add-task-modal');
		const input = document.getElementById('new-task-name');
	    input.focus();
	}
    
    function openTaskEditModal(id) {
        const task = getTasksForViewDate().find(t => t.id === id);
        if (!task) return;

        state.editingTaskId = id;
        document.getElementById('edit-task-name').value = task.name || '';
        document.getElementById('edit-task-time').value = task.estimatedTime || 0;
        updateProjectDropdowns();
		updateSectionDropdowns();
        document.getElementById('edit-task-project').value = task.projectId || '';
		document.getElementById('edit-task-section').value = task.sectionId || '';
        document.getElementById('edit-task-memo').value = task.memo || '';
		
        setTimeout(() => {
            const memoTextarea = document.getElementById('edit-task-memo');
            memoTextarea.style.height = 'auto';
            memoTextarea.style.height = (memoTextarea.scrollHeight) + 'px';
        }, 0);
        
        const subtaskToggle = document.getElementById('task-subtask-toggle');
        const subtaskContent = document.getElementById('task-subtask-content');
        const hasSubtasks = task.subtasks && task.subtasks.length > 0;
        subtaskToggle.checked = hasSubtasks;
        subtaskContent.classList.toggle('hidden', !hasSubtasks);
        
        const newToggle = subtaskToggle.cloneNode(true);
        subtaskToggle.parentNode.replaceChild(newToggle, subtaskToggle);
        newToggle.addEventListener('change', () => {
            subtaskContent.classList.toggle('hidden', !newToggle.checked);
        });

        renderSubtasksInModal('task', task.id);
        const newSubtaskInput = document.getElementById('new-subtask-name');
        const addSubtaskBtn = document.getElementById('add-subtask-btn');
        newSubtaskInput.value = '';
        const addSubtaskHandler = () => {
            const subtaskName = newSubtaskInput.value.trim();
            if (subtaskName) {
                addSubtaskToModal('task', subtaskName);
                newSubtaskInput.value = '';
                newSubtaskInput.focus();
            }
        };
        addSubtaskBtn.replaceWith(addSubtaskBtn.cloneNode(true));
        document.getElementById('add-subtask-btn').addEventListener('click', addSubtaskHandler);
        newSubtaskInput.addEventListener('keydown', (e) => {
             if(e.key === 'Enter') {
                e.preventDefault();
                addSubtaskHandler();
             }
        });


        const startTimeInput = document.getElementById('edit-task-startTime');
        const endTimeInput = document.getElementById('edit-task-endTime');
        
        startTimeInput.value = task.startTime ? new Date(task.startTime).toTimeString().slice(0, 5) : '';
        endTimeInput.value = task.endTime ? new Date(task.endTime).toTimeString().slice(0, 5) : '';
        
        document.getElementById('create-repeat-from-task').style.display = 'block';
        openModal('task-edit-modal');
		const input = document.getElementById('edit-task-name');
        input.focus();
    }
    
    function openArchivedTaskEditModal(dateKey, taskId) {
        if (!state.archivedTasks[dateKey]) return;
        const task = state.archivedTasks[dateKey].find(t => t.id === taskId);
        if (!task) return;

        state.editingTaskId = taskId;
        state.editingTaskDateKey = dateKey; 

        document.getElementById('edit-task-name').value = task.name || '';
        document.getElementById('edit-task-time').value = task.estimatedTime || 0;
        updateProjectDropdowns();
        document.getElementById('edit-task-project').value = task.projectId || '';
        document.getElementById('edit-task-memo').value = task.memo || '';
        
        const startTimeInput = document.getElementById('edit-task-startTime');
        const endTimeInput = document.getElementById('edit-task-endTime');
        
        startTimeInput.value = task.startTime ? new Date(task.startTime).toTimeString().slice(0, 5) : '';
        endTimeInput.value = task.endTime ? new Date(task.endTime).toTimeString().slice(0, 5) : '';
        
        document.getElementById('create-repeat-from-task').style.display = 'none';
        openModal('task-edit-modal');
		const input = document.getElementById('edit-task-name');
        input.focus();
    }


	function openMemoEditModal(id) {
	    const task = getTasksForViewDate().find(t => t.id === id);
	    if (!task) return;
	
	    state.editingMemoTaskId = id;
	    const memoTextEl = document.getElementById('edit-memo-text');
	    memoTextEl.value = task.memo || '';
	    openModal('memo-edit-modal');
	    memoTextEl.focus();
	}


    function saveMemoEdit() {
        const task = getTasksForViewDate().find(t => t.id === state.editingMemoTaskId);
        if (!task) return;

        const memo = document.getElementById('edit-memo-text').value.trim();
        task.memo = memo;

        closeModal('memo-edit-modal');
		task.updatedAt = new Date().toISOString();
        saveAndRender();
    }

    function saveTaskEdit() {
        const tasks = state.editingTaskDateKey 
            ? state.archivedTasks[state.editingTaskDateKey] 
            : getTasksForViewDate();
        
        if (!tasks) {
            closeModal('task-edit-modal');
            return;
        }

        const task = tasks.find(t => t.id === state.editingTaskId);
        if (!task) {
            closeModal('task-edit-modal');
            return;
        }

        const name = document.getElementById('edit-task-name').value.trim();
        const time = parseInt(document.getElementById('edit-task-time').value, 10);
        const projectId = document.getElementById('edit-task-project').value || null;
		const sectionId = document.getElementById('edit-task-section').value || null;
        const memo = document.getElementById('edit-task-memo').value.trim();

        if (!name || isNaN(time) || time < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return;
        }

        const sectionChanged = task.sectionId !== sectionId;

        task.name = name;
        task.estimatedTime = time;
        task.projectId = projectId;
		task.sectionId = sectionId;
        task.memo = memo;
        
        task.subtasks = getSubtasksFromModal('task');

		if (sectionChanged) {
	        const taskIndex = tasks.findIndex(t => t.id === state.editingTaskId);
	        if (taskIndex > -1) {
                const [movedTask] = tasks.splice(taskIndex, 1);

                let lastIndexInSection = -1;
                for (let i = tasks.length - 1; i >= 0; i--) {
                    if (tasks[i].sectionId === sectionId) {
                        lastIndexInSection = i;
                        break;
                    }
                }
                const insertIndex = lastIndexInSection !== -1 ? lastIndexInSection + 1 : tasks.length;
                tasks.splice(insertIndex, 0, movedTask);
            }
	    }

        const startTimeValue = document.getElementById('edit-task-startTime').value;
        const endTimeValue = document.getElementById('edit-task-endTime').value;

        if (startTimeValue) {
            const baseDate = task.startTime ? new Date(task.startTime) : (task.createdDate ? new Date(task.createdDate) : new Date());
            const [hours, minutes] = startTimeValue.split(':');
            baseDate.setHours(parseInt(hours, 10), parseInt(minutes, 10), 0, 0);
            task.startTime = baseDate.toISOString();
        } else {
            task.startTime = null;
        }

        if (endTimeValue) {
            const baseDate = task.endTime ? new Date(task.endTime) : (task.startTime ? new Date(task.startTime) : new Date());
            const [hours, minutes] = endTimeValue.split(':');
            baseDate.setHours(parseInt(hours, 10), parseInt(minutes, 10), 0, 0);
            task.endTime = baseDate.toISOString();
        } else {
            task.endTime = null;
        }
        
        task.actualTime = calculateActualTime(task);
        
        if (!state.editingTaskDateKey) {
            updateTaskStatus(task);
        }

        closeModal('task-edit-modal');
		task.updatedAt = new Date().toISOString();
        saveAndRender();
    }

    function createRepeatFromTask() {
        const task = getTasksForViewDate().find(t => t.id === state.editingTaskId);
        if (!task) return;

        const name = document.getElementById('edit-task-name').value.trim();
        const time = parseInt(document.getElementById('edit-task-time').value, 10);
        const projectId = document.getElementById('edit-task-project').value || null;
        const sectionId = document.getElementById('edit-task-section').value || null;
        if (!name || isNaN(time) || time < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return;
        }

        state.repeatTasks.push({
            id: 'rt' + Date.now(),
            name: name,
            estimatedTime: time,
            projectId: projectId,
            sectionId: sectionId, // 変更点: sectionIdを追加
            memo: task.memo || '',
			subtasks: JSON.parse(JSON.stringify(task.subtasks || [])),
            type: 'daily',
            value: null,
            startDate: null
        });

        closeModal('task-edit-modal');
        alert('リピートタスクを作成しました（毎日設定）。リピートタスクタブで詳細を編集できます。');
        saveAndRender();
    }

    function openRepeatEditModal(id) {
        const repeatTask = state.repeatTasks.find(rt => rt.id === id);
        if (!repeatTask) return;

        state.editingRepeatId = id;
        document.getElementById('edit-repeat-name').value = repeatTask.name || '';
        document.getElementById('edit-repeat-time').value = repeatTask.estimatedTime || 0;
        updateProjectDropdowns();
		updateSectionDropdowns();
        document.getElementById('edit-repeat-project').value = repeatTask.projectId || '';
		document.getElementById('edit-repeat-section').value = repeatTask.sectionId || '';
        document.getElementById('edit-repeat-memo').value = repeatTask.memo || '';
        document.getElementById('edit-repeat-type').value = repeatTask.type || 'daily';

		setTimeout(() => {
            const memoTextarea = document.getElementById('edit-repeat-memo');
            memoTextarea.style.height = 'auto';
            memoTextarea.style.height = (memoTextarea.scrollHeight) + 'px';
        }, 0);

        const subtaskToggle = document.getElementById('repeat-subtask-toggle');
        const subtaskContent = document.getElementById('repeat-subtask-content');
        const hasSubtasks = repeatTask.subtasks && repeatTask.subtasks.length > 0;
        subtaskToggle.checked = hasSubtasks;
        subtaskContent.classList.toggle('hidden', !hasSubtasks);
        
        const newToggle = subtaskToggle.cloneNode(true);
        subtaskToggle.parentNode.replaceChild(newToggle, subtaskToggle);
        newToggle.addEventListener('change', () => {
            subtaskContent.classList.toggle('hidden', !newToggle.checked);
        });
        
        renderSubtasksInModal('repeat', repeatTask.id);
        const newSubtaskInput = document.getElementById('new-repeat-subtask-name');
        const addSubtaskBtn = document.getElementById('add-repeat-subtask-btn');
        newSubtaskInput.value = '';
        const addSubtaskHandler = () => {
            const subtaskName = newSubtaskInput.value.trim();
            if (subtaskName) {
                addSubtaskToModal('repeat', subtaskName);
                newSubtaskInput.value = '';
                newSubtaskInput.focus();
            }
        };
        addSubtaskBtn.replaceWith(addSubtaskBtn.cloneNode(true));
        document.getElementById('add-repeat-subtask-btn').addEventListener('click', addSubtaskHandler);
        newSubtaskInput.addEventListener('keydown', (e) => {
             if(e.key === 'Enter') {
                e.preventDefault();
                addSubtaskHandler();
             }
        });


        const weeklyContainer = document.getElementById('edit-repeat-weekly-days');
        if (weeklyContainer.childElementCount === 0) {
            ['日','月','火','水','木','金','土'].forEach((d, i) => {
                weeklyContainer.innerHTML += `<label class="inline-flex items-center"><input type="checkbox" value="${i}" class="form-checkbox"><span class="ml-2 text-sm">${d}</span></label>`;
            });
        }
        
        // --- 値のクリアと設定 ---
        document.querySelectorAll('#edit-repeat-weekly-days input').forEach(cb => cb.checked = false);
        document.getElementById('edit-repeat-weekly-interval').value = '1';
        document.getElementById('edit-repeat-weekly-start-date').value = '';
        document.getElementById('edit-repeat-monthly-day').value = '';
        document.querySelector('input[name="edit-monthly-type"][value="day"]').checked = true;
        document.getElementById('edit-repeat-monthly-day-options').classList.remove('hidden');
        document.getElementById('edit-repeat-monthly-weekday-options').classList.add('hidden');
        document.getElementById('edit-yearly-month').value = '';
        document.getElementById('edit-yearly-day').value = '';
        document.getElementById('edit-repeat-interval-days').value = '';
        document.getElementById('edit-repeat-interval-start-date').value = '';
        
        // --- 保存された値の反映 ---
        if (repeatTask.type === 'weekly') {
            if (Array.isArray(repeatTask.value)) {
                document.querySelectorAll('#edit-repeat-weekly-days input').forEach(cb => {
                    cb.checked = repeatTask.value.includes(parseInt(cb.value, 10));
                });
            }
            document.getElementById('edit-repeat-weekly-interval').value = repeatTask.weekInterval || '1';
            document.getElementById('edit-repeat-weekly-start-date').value = repeatTask.startDate || '';
        } else if (repeatTask.type === 'monthly' && repeatTask.value) {
            if (repeatTask.value.type === 'day') {
                document.querySelector('input[name="edit-monthly-type"][value="day"]').checked = true;
                document.getElementById('edit-repeat-monthly-day').value = repeatTask.value.day || '';
            } else if (repeatTask.value.type === 'weekday') {
                document.querySelector('input[name="edit-monthly-type"][value="weekday"]').checked = true;
                document.getElementById('edit-monthly-week').value = repeatTask.value.week || '1';
                document.getElementById('edit-monthly-weekday').value = repeatTask.value.weekday || '0';
                document.getElementById('edit-repeat-monthly-day-options').classList.add('hidden');
                document.getElementById('edit-repeat-monthly-weekday-options').classList.remove('hidden');
            }
        } else if (repeatTask.type === 'yearly' && repeatTask.value) {
            document.getElementById('edit-yearly-month').value = repeatTask.value.month || '';
            document.getElementById('edit-yearly-day').value = repeatTask.value.day || '';
        } else if (repeatTask.type === 'interval') {
            document.getElementById('edit-repeat-interval-days').value = repeatTask.value || '';
            document.getElementById('edit-repeat-interval-start-date').value = repeatTask.startDate || '';
        }

        document.getElementById('edit-repeat-weekly-options').classList.toggle('hidden', repeatTask.type !== 'weekly');
        document.getElementById('edit-repeat-monthly-options').classList.toggle('hidden', repeatTask.type !== 'monthly');
        document.getElementById('edit-repeat-yearly-options').classList.toggle('hidden', repeatTask.type !== 'yearly');
        document.getElementById('edit-repeat-interval-options').classList.toggle('hidden', repeatTask.type !== 'interval');
        
        // 編集モーダル内の月間ラジオボタンのイベントリスナー（毎回再設定）
        document.querySelectorAll('input[name="edit-monthly-type"]').forEach(radio => {
            const listener = (e) => {
                const isDayType = e.target.value === 'day';
                document.getElementById('edit-repeat-monthly-day-options').classList.toggle('hidden', !isDayType);
                document.getElementById('edit-repeat-monthly-weekday-options').classList.toggle('hidden', isDayType);
            };
            // 既存のリスナーを削除して再追加
            radio.replaceWith(radio.cloneNode(true));
            document.querySelector(`input[name="edit-monthly-type"][value="${radio.value}"]`).addEventListener('change', listener);
        });
        // ラジオボタンの状態を再適用
        if (repeatTask.type === 'monthly' && repeatTask.value) {
             document.querySelector(`input[name="edit-monthly-type"][value="${repeatTask.value.type}"]`).checked = true;
        }

        openModal('repeat-edit-modal');
		const input = document.getElementById('edit-repeat-name');
		input.focus();
    }

    function saveRepeatEdit() {
        const repeatTask = state.repeatTasks.find(rt => rt.id === state.editingRepeatId);
        if (!repeatTask) return;

        const name = document.getElementById('edit-repeat-name').value.trim();
        const time = parseInt(document.getElementById('edit-repeat-time').value, 10);
        const projectId = document.getElementById('edit-repeat-project').value || null;
		const sectionId = document.getElementById('edit-repeat-section').value || null;
        const memo = document.getElementById('edit-repeat-memo').value.trim();
        const type = document.getElementById('edit-repeat-type').value;

        if (!name || isNaN(time) || time < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return;
        }

        let value = null;
        let startDate = repeatTask.startDate || null;
        let weekInterval = 1;

        if (type === 'weekly') {
            value = Array.from(document.querySelectorAll('#edit-repeat-weekly-days input:checked')).map(cb => parseInt(cb.value, 10));
            if (value.length === 0) { alert('曜日を選択してください。'); return; }
            weekInterval = parseInt(document.getElementById('edit-repeat-weekly-interval').value, 10) || 1;
            startDate = document.getElementById('edit-repeat-weekly-start-date').value || new Date().toISOString().slice(0,10);
        } else if (type === 'monthly') {
            const monthlyType = document.querySelector('input[name="edit-monthly-type"]:checked').value;
            if (monthlyType === 'day') {
                const day = parseInt(document.getElementById('edit-repeat-monthly-day').value, 10);
                if (isNaN(day) || day < 1 || day > 31) { alert('有効な日付を入力してください。'); return; }
                value = { type: 'day', day: day };
            } else {
                const week = parseInt(document.getElementById('edit-monthly-week').value, 10);
                const weekday = parseInt(document.getElementById('edit-monthly-weekday').value, 10);
                value = { type: 'weekday', week: week, weekday: weekday };
            }
        } else if (type === 'yearly') {
            const month = parseInt(document.getElementById('edit-yearly-month').value, 10);
            const day = parseInt(document.getElementById('edit-yearly-day').value, 10);
            if (isNaN(month) || month < 1 || month > 12 || isNaN(day) || day < 1 || day > 31) {
                alert('有効な月日を入力してください。'); return;
            }
            value = { month, day };
        } else if (type === 'interval') {
            value = parseInt(document.getElementById('edit-repeat-interval-days').value, 10);
            if (isNaN(value) || value < 1) { alert('有効な間隔（日数）を入力してください。'); return; }
            const startDateInput = document.getElementById('edit-repeat-interval-start-date').value;
            if (startDateInput) {
                startDate = startDateInput;
            } else if (!startDate) {
                startDate = new Date().toISOString().slice(0,10);
            }
        }

        repeatTask.name = name;
        repeatTask.estimatedTime = time;
        repeatTask.projectId = projectId;
		repeatTask.sectionId = sectionId;
        repeatTask.memo = memo;
        repeatTask.type = type;
        repeatTask.value = value;
        repeatTask.startDate = startDate;
        repeatTask.weekInterval = weekInterval;
        repeatTask.subtasks = getSubtasksFromModal('repeat');

        closeModal('repeat-edit-modal');
        saveAndRender();
    }

    function renderProjects() {
        const container = document.getElementById('projects-container');
        if (isMobile()) {
            renderProjectCards(container);
        } else {
            renderProjectTable(container);
        }
    }

    function renderProjectTable(container) {
        container.innerHTML = `<div class="overflow-x-auto">
            <table class="min-w-full bg-white">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="py-2 px-4 border-b w-8"></th>
                        <th class="py-2 px-4 border-b w-20">色</th>
                        <th class="py-2 px-4 border-b text-left">プロジェクト名</th>
                        <th class="py-2 px-4 border-b">操作</th>
                    </tr>
                </thead>
                <tbody id="projects-list"></tbody>
            </table>
        </div>`;
        const list = document.getElementById('projects-list');
        list.innerHTML = '';
        state.projects.forEach((p, idx) => {
            const tr = document.createElement('tr');
            tr.className = 'border-b project-row';
            tr.dataset.id = p.id;
            tr.dataset.index = idx;
            tr.draggable = true;
            tr.innerHTML = `
                <td class="py-2 px-4 text-center"><span class="drag-handle">⋮⋮</span></td>
                <td class="pt-2 px-4 text-center"><span class="inline-block w-4 h-4 rounded-full" style="background-color: ${p.color};"></span></td>
                <td class="py-2 px-4">${escapeHtml(p.name)}</td>
                <td class="py-2 px-4 text-center space-x-1">
                    <button class="edit-project-btn text-gray-400 hover:text-blue-500 p-1" data-id="${p.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                    </button>
                    <button class="delete-project-btn text-gray-400 hover:text-red-500 p-1" data-id="${p.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg>
                    </button>
                </td>
            `;
            list.appendChild(tr);
        });

        setupDragAndDrop('.project-row', state.projects, 'project');
        container.querySelectorAll('.edit-project-btn').forEach(btn => btn.addEventListener('click', (e) => editProject(e.currentTarget.dataset.id)));
        container.querySelectorAll('.delete-project-btn').forEach(btn => btn.addEventListener('click', (e) => deleteProject(e.currentTarget.dataset.id)));
    }

    function renderProjectCards(container) {
        container.innerHTML = '';
        const wrapper = document.createElement('div');
        wrapper.className = 'space-y-3';
        state.projects.forEach((p, idx) => {
            const card = document.createElement('div');
            card.className = 'bg-white p-3 shadow rounded-lg flex items-center gap-3 project-row';
            card.dataset.id = p.id;
            card.dataset.index = idx;
            card.draggable = true;
            card.innerHTML = `
                <span class="drag-handle text-gray-400 hover:text-gray-600 cursor-move">⋮⋮</span>
                <span class="inline-block w-5 h-5 rounded-full flex-shrink-0" style="background-color: ${p.color};"></span>
                <span class="flex-1 font-semibold truncate">${escapeHtml(p.name)}</span>
                <div class="space-x-1">
                    <button class="edit-project-btn text-gray-400 hover:text-blue-500 p-1" data-id="${p.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                    </button>
                    <button class="delete-project-btn text-gray-400 hover:text-red-500 p-1" data-id="${p.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg>
                    </button>
                </div>
            `;
            wrapper.appendChild(card);
        });
        container.appendChild(wrapper);
        setupDragAndDrop('.project-row', state.projects, 'project');
        container.querySelectorAll('.edit-project-btn').forEach(btn => btn.addEventListener('click', (e) => editProject(e.currentTarget.dataset.id)));
        container.querySelectorAll('.delete-project-btn').forEach(btn => btn.addEventListener('click', (e) => deleteProject(e.currentTarget.dataset.id)));
    }

	function renderRepeatTasks() {
	    const container = document.getElementById('repeat-tasks-container');
	    
	    const addWeeklyDaysContainer = document.getElementById('repeat-weekly-days');
	    if (addWeeklyDaysContainer && addWeeklyDaysContainer.childElementCount === 0) {
	        ['日','月','火','水','木','金','土'].forEach((d, i) => {
	            addWeeklyDaysContainer.innerHTML += `<label class="inline-flex items-center"><input type="checkbox" value="${i}" class="form-checkbox"><span class="ml-2 text-sm">${d}</span></label>`;
	        });
	    }
	
	    const sortedSections = [...state.sections].sort((a, b) => a.startTime.localeCompare(b.startTime));
	    const tasksBySection = { 'null': [] };
	    sortedSections.forEach(s => tasksBySection[s.id] = []);
	    state.repeatTasks.forEach(task => {
	        const sectionId = task.sectionId || 'null';
	        if (tasksBySection.hasOwnProperty(sectionId)) {
	            tasksBySection[sectionId].push(task);
	        } else {
	            tasksBySection['null'].push(task);
	        }
	    });
	    const sectionOrder = ['null', ...sortedSections.map(s => s.id)];
	
	    if (isMobile()) {
	        container.innerHTML = '';
	        const wrapper = document.createElement('div');
	        wrapper.className = 'space-y-3';
	        sectionOrder.forEach(sectionId => {
	            const sectionTasks = tasksBySection[sectionId];
	            if (sectionId === 'null' && sectionTasks.length === 0) return;
	
	            const { name, range } = getSectionDisplayInfo(sectionId);
	            const sectionHeader = document.createElement('div');
	            sectionHeader.className = 'text-sm font-bold text-gray-500 pt-4 pb-1 px-2';
	            sectionHeader.textContent = name + ' ' + range;
	            wrapper.appendChild(sectionHeader);
	
	            renderRepeatTaskCards(wrapper, sectionTasks);
	
	            if (sectionTasks.length === 0) {
	                const dropTarget = document.createElement('div');
	                dropTarget.className = 'empty-section-drop-target text-center text-gray-400 text-xs border-dashed border-gray-300 rounded-lg';
	                dropTarget.textContent = 'ここにタスクをドロップ';
	                dropTarget.dataset.sectionId = sectionId;
	                wrapper.appendChild(dropTarget);
	            }
	        });
	        container.appendChild(wrapper);
	
	    } else {
	        container.innerHTML = `<div class="overflow-x-auto">
	            <table class="min-w-full bg-white">
	                <thead class="bg-gray-100">
	                    <tr>
	                        <th class="py-2 px-4 border-b w-8"></th>
	                        <th class="py-2 px-4 border-b text-left">タスク名</th>
	                        <th class="py-2 px-4 border-b text-left">プロジェクト</th>
	                        <th class="py-2 px-4 border-b text-left">見積時間</th>
	                        <th class="py-2 px-4 border-b text-left">繰り返し</th>
	                        <th class="py-2 px-4 border-b">操作</th>
	                    </tr>
	                </thead>
	                <tbody id="repeat-tasks-list"></tbody>
	            </table>
	        </div>`;
	        const list = container.querySelector('#repeat-tasks-list');
	        list.innerHTML = '';
	
	        sectionOrder.forEach(sectionId => {
	            const sectionTasks = tasksBySection[sectionId];
	            if (sectionId === 'null' && sectionTasks.length === 0) return;
	
	            const { name, range } = getSectionDisplayInfo(sectionId);
	            const headerRow = document.createElement('tr');
	            headerRow.className = 'bg-gray-100';
	            headerRow.dataset.sectionId = sectionId;
	            headerRow.innerHTML = `<td colspan="6" class="py-1 px-3 text-sm font-bold text-gray-600">${name} ${range}</td>`;
	            list.appendChild(headerRow);
	            
	            renderRepeatTaskTable(list, sectionTasks);
	        });
	    }
		
		setupDragAndDrop('.repeat-task-row', state.repeatTasks, 'repeat');
	    container.querySelectorAll('.generate-single-repeat-btn').forEach(btn => btn.addEventListener('click', (e) => generateSingleRepeatTask(e.currentTarget.dataset.id)));
	    container.querySelectorAll('.edit-repeat-task-btn').forEach(btn => btn.addEventListener('click', (e) => openRepeatEditModal(e.currentTarget.dataset.id)));
	    container.querySelectorAll('.delete-repeat-task-btn').forEach(btn => btn.addEventListener('click', (e) => deleteRepeatTask(e.currentTarget.dataset.id)));
	}

	function renderRepeatTaskTable(list, tasksToRender) {
	    if (tasksToRender.length === 0) {
	        const parentHeader = list.lastElementChild;
	        if (parentHeader && parentHeader.dataset.sectionId) {
	             const tr = document.createElement('tr');
	             tr.className = 'empty-section-drop-target';
	             tr.dataset.sectionId = parentHeader.dataset.sectionId;
	             tr.innerHTML = `<td colspan="6" class="px-4 text-center text-gray-400 text-xs">ここにタスクをドロップできます</td>`;
	             list.appendChild(tr);
	        }
	        return;
	    }
	
	    tasksToRender.forEach(rt => {
	        const allTasks = state.repeatTasks;
	        const idx = allTasks.findIndex(t => t.id === rt.id);
	        const project = state.projects.find(p => p.id === rt.projectId) || { name: 'N/A' };
	        let repeatText = '';
	        const weekdays = ['日','月','火','水','木','金','土'];
	
	        switch (rt.type) {
	            case 'daily':
	                repeatText = '毎日';
	                break;
	            case 'weekly':
	                const intervalText = (rt.weekInterval && rt.weekInterval > 1) ? `${rt.weekInterval}週ごと ` : '';
	                const days = Array.isArray(rt.value) ? rt.value.map(i => weekdays[i]).join(',') : '';
	                repeatText = `毎週 ${intervalText}(${days})`;
	                break;
	            case 'monthly':
	                if (rt.value) {
	                    if (rt.value.type === 'day') {
	                        repeatText = `毎月 ${rt.value.day}日`;
	                    } else if (rt.value.type === 'weekday') {
	                        const weekStr = ['第1', '第2', '第3', '第4', '最終'][rt.value.week - 1];
	                        const dayStr = weekdays[rt.value.weekday];
	                        repeatText = `毎月 ${weekStr}${dayStr}曜日`;
	                    }
	                }
	                break;
	            case 'yearly':
	                if (rt.value) {
	                    repeatText = `毎年 ${rt.value.month}月${rt.value.day}日`;
	                }
	                break;
	            case 'interval':
	                repeatText = `${rt.value}日ごと (基準日: ${rt.startDate || '未設定'})`;
	                break;
	            default:
	                repeatText = '不明';
	        }
	
	        const memoIcon = rt.memo ? `<span class="tooltip-container"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block ml-1 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg><span class="custom-tooltip">${escapeHtml(rt.memo)}</span></span>` : '';
	
	        const tr = document.createElement('tr');
	        tr.className = 'border-b repeat-task-row';
	        tr.dataset.id = rt.id;
	        tr.dataset.index = idx;
	        tr.dataset.sectionId = rt.sectionId || 'null';
	        tr.draggable = true;
	        tr.innerHTML = `
	            <td class="py-2 px-4 text-center"><span class="drag-handle">⋮⋮</span></td>
	            <td class="py-2 px-4"><div class="flex items-center">${formatTaskName(rt.name)}${memoIcon}</div></td>
	            <td class="py-2 px-4">${escapeHtml(project.name)}</td>
	            <td class="py-2 px-4">${rt.estimatedTime} 分</td>
	            <td class="py-2 px-4 text-sm">${escapeHtml(repeatText)}</td>
	            <td class="py-2 px-4 text-center space-x-1 whitespace-nowrap">
	                <button class="generate-single-repeat-btn text-gray-400 hover:text-green-500 p-1" data-id="${rt.id}" title="今日のタスクとして生成"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg></button>
	                <button class="edit-repeat-task-btn text-gray-400 hover:text-blue-500 p-1" data-id="${rt.id}"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg></button>
	                <button class="delete-repeat-task-btn text-gray-400 hover:text-red-500 p-1" data-id="${rt.id}"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg></button>
	            </td>
	        `;
	        list.appendChild(tr);
	    });
	}

	function renderRepeatTaskCards(wrapper, tasksToRender) {
	    tasksToRender.forEach(rt => {
	        const allTasks = state.repeatTasks;
	        const idx = allTasks.findIndex(t => t.id === rt.id);
	        const project = state.projects.find(p => p.id === rt.projectId) || { name: 'N/A', color: '#cccccc' };
	        let repeatText = '';
	        const weekdays = ['日','月','火','水','木','金','土'];
	
	        switch (rt.type) {
	            case 'daily':
	                repeatText = '毎日';
	                break;
	            case 'weekly':
	                const intervalText = (rt.weekInterval && rt.weekInterval > 1) ? `${rt.weekInterval}週ごと ` : '';
	                const days = Array.isArray(rt.value) ? rt.value.map(i => weekdays[i]).join(',') : '';
	                repeatText = `毎週 ${intervalText}(${days})`;
	                break;
	            case 'monthly':
	                if (rt.value) {
	                    if (rt.value.type === 'day') {
	                        repeatText = `毎月 ${rt.value.day}日`;
	                    } else if (rt.value.type === 'weekday') {
	                        const weekStr = ['第1', '第2', '第3', '第4', '最終'][rt.value.week - 1];
	                        const dayStr = weekdays[rt.value.weekday];
	                        repeatText = `毎月 ${weekStr}${dayStr}曜日`;
	                    }
	                }
	                break;
	            case 'yearly':
	                if (rt.value) {
	                    repeatText = `毎年 ${rt.value.month}月${rt.value.day}日`;
	                }
	                break;
	            case 'interval':
	                repeatText = `${rt.value}日ごと`;
	                break;
	            default:
	                repeatText = '不明';
	        }
	
	        const card = document.createElement('div');
	        card.className = 'bg-white p-3 shadow border-l-4 repeat-task-row';
	        card.style.borderLeftColor = project.color;
	        card.dataset.id = rt.id;
	        card.dataset.index = idx;
	        card.dataset.sectionId = rt.sectionId || 'null';
	        card.draggable = true;
	
	        const memoIcon = rt.memo ? `<span class="tooltip-container"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block ml-1 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg><span class="custom-tooltip">${escapeHtml(rt.memo)}</span></span>` : '';
	
	        card.innerHTML = `
	            <div class="flex items-start gap-3">
	                <span class="drag-handle text-gray-400 hover:text-gray-600 cursor-move pt-1">⋮⋮</span>
	                <div class="flex-1 min-w-0">
	                    <div class="flex justify-between items-start">
	                         <h3 class="font-semibold text-base flex items-center pr-2" title="${escapeHtml(rt.name || '')}">
	                           ${formatTaskName(rt.name)} ${memoIcon}
	                        </h3>
	                         <div class="flex space-x-1 flex-shrink-0">
	                            <button class="generate-single-repeat-btn text-gray-400 hover:text-green-500 p-1" data-id="${rt.id}" title="今日のタスクとして生成"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg></button>
	                            <button class="edit-repeat-task-btn text-gray-400 hover:text-blue-500 p-1" data-id="${rt.id}"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg></button>
	                            <button class="delete-repeat-task-btn text-gray-400 hover:text-red-500 p-1" data-id="${rt.id}"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg></button>
	                        </div>
	                    </div>
	                    <p class="text-sm text-gray-500">${escapeHtml(project.name)}</p>
	                    <div class="flex items-center justify-between text-xs text-gray-600 mt-1">
	                        <span>見積: ${rt.estimatedTime || 0}分</span>
	                        <span>${escapeHtml(repeatText)}</span>
	                    </div>
	                </div>
	            </div>
	        `;
	        wrapper.appendChild(card);
	    });
	}

    function updateProjectDropdowns() {
        const selects = document.querySelectorAll('#new-task-project, #repeat-task-project, #edit-task-project, #edit-repeat-project');
        selects.forEach(select => {
            const cur = select.value;
            select.innerHTML = '<option value="">プロジェクトなし</option>' + state.projects.map(p => `<option value="${p.id}">${escapeHtml(p.name)}</option>`).join('');
            if (cur) select.value = cur;
        });
    }

	function addTask(name = null, time = null, projectId = null, sectionId = null, isInterrupt = false, options = {}) {
	    const taskName = name.trim();
	    const estimatedTime = parseInt(time, 10);
	
	    if (!taskName || isNaN(estimatedTime) || estimatedTime < 0) {
	        alert('タスク名と見積時間を正しく入力してください。');
	        return null;
	    }
	
	    const tasks = getTasksForViewDate();
	    const newTask = {
	        id: 't' + Date.now() + Math.random(),
	        name: taskName,
	        projectId: projectId || null,
	        sectionId: sectionId || null,
	        estimatedTime,
	        actualTime: 0,
	        status: 'pending',
	        isInterrupt: !!isInterrupt,
	        memo: '',
			subtasks: [],
	        startTime: null,
	        endTime: null,
	        createdDate: state.viewDate,
			updatedAt: new Date().toISOString(),
	        ...options
	    };
	
	    let insertIndex;
	    if (isInterrupt) {
	        const firstPendingIndex = tasks.findIndex(t => t.status !== 'completed');
	        insertIndex = firstPendingIndex === -1 ? 0 : firstPendingIndex;
	    } else {
            // セクションの表示順序を定義
            const sortedSections = [...state.sections].sort((a, b) => a.startTime.localeCompare(b.startTime));
            const sectionOrder = ['null', ...sortedSections.map(s => s.id)];

            const targetSectionId = sectionId || 'null';
            const targetSectionOrderIndex = sectionOrder.indexOf(targetSectionId);
            
            // 挿入すべき位置を探す
            // デフォルトはリストの末尾
            insertIndex = tasks.length; 

            // 1. ターゲットセクションの最後のタスクを探す
            let lastTaskInTargetSectionIndex = -1;
            for (let i = tasks.length - 1; i >= 0; i--) {
                if ((tasks[i].sectionId || 'null') === targetSectionId) {
                    lastTaskInTargetSectionIndex = i;
                    break;
                }
            }

            if (lastTaskInTargetSectionIndex !== -1) {
                // 同じセクションのタスクが既にあれば、その直後に追加
                insertIndex = lastTaskInTargetSectionIndex + 1;
            } else {
                // ターゲットセクションにタスクがない場合
                // ターゲットセクションより後のセクションに属する最初のタスクを探す
                let firstTaskInNextSectionIndex = -1;
                for (let i = 0; i < tasks.length; i++) {
                    const taskSectionOrderIndex = sectionOrder.indexOf(tasks[i].sectionId || 'null');
                    if (taskSectionOrderIndex > targetSectionOrderIndex) {
                        firstTaskInNextSectionIndex = i;
                        break;
                    }
                }

                if (firstTaskInNextSectionIndex !== -1) {
                    // 後のセクションのタスクがあれば、その直前に追加
                    insertIndex = firstTaskInNextSectionIndex;
                }
                // 後のセクションのタスクがなければ、デフォルトの `tasks.length` (末尾) が使われる
            }
	    }
	
	    tasks.splice(insertIndex, 0, newTask);
	    setTasksForViewDate(tasks);
	
	    state.focusedTaskId = newTask.id;
	    saveAndRender();
	    return newTask;
	}

	function deleteTask(id) {
	    const tasks = getTasksForViewDate();
	    const task = tasks.find(t => t.id === id);
	    if (!task) return;

	    if (!confirm(`タスク「${task.name}」を削除しますか？`)) return;
	
	    const allTasksForDate = state.dailyTasks[state.viewDate] || [];
	    const index = allTasksForDate.findIndex(t => t.id === id);
	    if (index === -1) return;
	
	    // 1. タスクに削除フラグを立てる（論理削除）
	    const taskToDelete = allTasksForDate[index];
	    taskToDelete.isDeleted = true;
	    taskToDelete.updatedAt = new Date().toISOString();
	
	    // 2. 削除後にフォーカスする次のタスクを決定する
	    let nextFocusedTask = null;
	    // まず、削除したタスクより下にある未削除のタスクを探す
	    for (let i = index + 1; i < allTasksForDate.length; i++) {
	        if (!allTasksForDate[i].isDeleted) {
	            nextFocusedTask = allTasksForDate[i];
	            break;
	        }
	    }
	    // 下に見つからなければ、上にある未削除のタスクを探す
	    if (!nextFocusedTask) {
	        for (let i = index - 1; i >= 0; i--) {
	            if (!allTasksForDate[i].isDeleted) {
	                nextFocusedTask = allTasksForDate[i];
	                break;
	            }
	        }
	    }
	
	    // 3. stateのフォーカスIDを更新する
	    state.focusedTaskId = nextFocusedTask ? nextFocusedTask.id : null;
	
	    // 4. 状態を保存し、画面を再描画する
	    saveAndRender();
	}

    function deleteArchivedTask(dateKey, taskId) {
        if (!state.archivedTasks[dateKey]) return;
        const task = state.archivedTasks[dateKey].find(t => t.id === taskId);
        if (!task) return;

        if (!confirm(`アーカイブ済みタスク「${task.name}」を削除しますか？この操作は元に戻せません。`)) return;
        if (state.archivedTasks[dateKey]) {
            state.archivedTasks[dateKey] = state.archivedTasks[dateKey].filter(t => t.id !== taskId);
            if (state.archivedTasks[dateKey].length === 0) {
                delete state.archivedTasks[dateKey];
            }
        }
        saveAndRender();
    }
    
	function postponeTask(id) {
	    // isDeletedフラグを持つタスクも含めた、その日の全タスクリストを取得します
	    const allTasksForDate = state.dailyTasks[state.viewDate] || [];
	    const taskIndex = allTasksForDate.findIndex(t => t.id === id);
	    if (taskIndex === -1) return;
	
	    // 1. 翌日にタスクのコピーを追加します
	    const taskToMove = { ...allTasksForDate[taskIndex] }; // 元のタスクをコピー
	
	    const nextDay = new Date(state.viewDate);
	    nextDay.setDate(nextDay.getDate() + 1);
	    const nextDateStr = getFormattedDate(nextDay);
	    
	    if (!state.dailyTasks[nextDateStr]) {
	        state.dailyTasks[nextDateStr] = [];
	    }
	    
	    // 実行状態などをリセットし、クリーンな状態で翌日に追加します
	    taskToMove.status = 'pending';
	    taskToMove.startTime = null;
	    taskToMove.endTime = null;
	    taskToMove.actualTime = 0;
	    delete taskToMove.isDeleted; // もしisDeletedフラグが存在すれば削除
	    taskToMove.updatedAt = new Date().toISOString(); // 更新日時を最新に
	
	    state.dailyTasks[nextDateStr].unshift(taskToMove);
	
	    // 2. 元の日のタスクを物理削除せず、「論理削除」の状態にします
	    const originalTask = allTasksForDate[taskIndex];
	    originalTask.isDeleted = true;
	    originalTask.updatedAt = new Date().toISOString(); // 更新日時を記録して同期の競合を防ぎます
	
	    // 実行中のタスクだった場合はタイマーを停止します
	    if (state.activeTaskId === id) stopActiveTimer();
	    
	    // 3. フォーカスを次の適切なタスクに移動させます
	    if (state.focusedTaskId === id) {
	        let nextFocusedTask = null;
	        // 先送りしたタスクより下にある、削除されていないタスクを探します
	        for (let i = taskIndex + 1; i < allTasksForDate.length; i++) {
	            if (!allTasksForDate[i].isDeleted) {
	                nextFocusedTask = allTasksForDate[i];
	                break;
	            }
	        }
	        // 見つからなければ、上にあるタスクを探します
	        if (!nextFocusedTask) {
	            for (let i = taskIndex - 1; i >= 0; i--) {
	                if (!allTasksForDate[i].isDeleted) {
	                    nextFocusedTask = allTasksForDate[i];
	                    break;
	                }
	            }
	        }
	        state.focusedTaskId = nextFocusedTask ? nextFocusedTask.id : null;
	    }
	    
	    saveAndRender();
	    // ユーザーへのフィードバックを追加
	    showToast(`タスクを翌日に先送りしました。`);
	}

	function moveTaskToToday(id) {
	    // 表示中の未来日のタスクリストを取得
	    const allTasksForDate = state.dailyTasks[state.viewDate] || [];
	    const taskIndex = allTasksForDate.findIndex(t => t.id === id);
	    if (taskIndex === -1) return;
	
	    // 1. 未来日のリストからタスクを抜き出す
	    const [taskToMove] = allTasksForDate.splice(taskIndex, 1);
	
	    // 2. 移動に備えてタスクの状態をリセット
	    taskToMove.status = 'pending';
	    taskToMove.startTime = null;
	    taskToMove.endTime = null;
	    taskToMove.actualTime = 0;
	    delete taskToMove.isDeleted;
	    taskToMove.updatedAt = new Date().toISOString();
	    taskToMove.createdDate = getFormattedDate(new Date()); // 生成日を今日に更新
	
	    // 3. 当日のタスクリストに追加
	    const todayStr = getFormattedDate(new Date());
	    if (!state.dailyTasks[todayStr]) {
	        state.dailyTasks[todayStr] = [];
	    }
	    const todayTasks = state.dailyTasks[todayStr];
	    
	    // 4. セクションに基づいた正しい位置に挿入する
	    const sortedSections = [...state.sections].sort((a, b) => a.startTime.localeCompare(b.startTime));
	    const sectionOrder = ['null', ...sortedSections.map(s => s.id)];
	    const targetSectionId = taskToMove.sectionId || 'null';
	    const targetSectionOrderIndex = sectionOrder.indexOf(targetSectionId);
	
	    let insertIndex = todayTasks.length;
	
	    let lastTaskInTargetSectionIndex = -1;
	    for (let i = todayTasks.length - 1; i >= 0; i--) {
	        if ((todayTasks[i].sectionId || 'null') === targetSectionId) {
	            lastTaskInTargetSectionIndex = i;
	            break;
	        }
	    }
	
	    if (lastTaskInTargetSectionIndex !== -1) {
	        insertIndex = lastTaskInTargetSectionIndex + 1;
	    } else {
	        let firstTaskInNextSectionIndex = -1;
	        for (let i = 0; i < todayTasks.length; i++) {
	            const taskSectionOrderIndex = sectionOrder.indexOf(todayTasks[i].sectionId || 'null');
	            if (taskSectionOrderIndex > targetSectionOrderIndex) {
	                firstTaskInNextSectionIndex = i;
	                break;
	            }
	        }
	        if (firstTaskInNextSectionIndex !== -1) {
	            insertIndex = firstTaskInNextSectionIndex;
	        }
	    }
	    todayTasks.splice(insertIndex, 0, taskToMove);
	
	    // 5. 未来日のリストでフォーカスを調整
	    if (state.focusedTaskId === id) {
	        let nextFocusedTask = null;
	        if (taskIndex < allTasksForDate.length) {
	            nextFocusedTask = allTasksForDate[taskIndex];
	        } else if (allTasksForDate.length > 0) {
	            nextFocusedTask = allTasksForDate[allTasksForDate.length - 1];
	        }
	        state.focusedTaskId = nextFocusedTask ? nextFocusedTask.id : null;
	    }
	
	    saveAndRender();
	    showToast('タスクを当日に移動しました。');
	}

    function toggleTimer(id, forceStop = false) {
        const tasks = getTasksForViewDate();
        const task = tasks.find(t => t.id === id);
        if (!task) return;

        if (state.activeTaskId === id && !forceStop) {
            task.endTime = new Date().toISOString();
            task.actualTime = calculateActualTime(task);
            updateTaskStatus(task);
            stopActiveTimer();
            const nextTask = tasks.find(t => t.status !== 'completed');
            state.focusedTaskId = nextTask ? nextTask.id : null;
            task.updatedAt = new Date().toISOString();
        } 
        else {
            if (state.activeTaskId) {
                const runningTask = tasks.find(t => t.id === state.activeTaskId);
                if (runningTask) {
                    runningTask.endTime = new Date().toISOString();
                    runningTask.actualTime = calculateActualTime(runningTask);
                    updateTaskStatus(runningTask);
                    runningTask.updatedAt = new Date().toISOString();
                }
                stopActiveTimer();
            }

            if (!forceStop) {
                if (task.startTime && task.status !== 'running') {
                    if (confirm('このタスクは既に一度開始されています。新しいタスクとして再開しますか？')) {
                        const newTask = addTask(task.name, task.estimatedTime, task.projectId, task.isInterrupt, {
                            memo: task.memo,
                            originRepeatId: task.originRepeatId
                        });
                        task.endTime = task.endTime || new Date().toISOString();
                        task.actualTime = calculateActualTime(task);
                        updateTaskStatus(task);
                        task.updatedAt = new Date().toISOString();
                        
                        toggleTimer(newTask.id);
                        return;
                    } else {
						 task.updatedAt = new Date().toISOString();
                         saveAndRender();
                         return;
                    }
                }
                
                task.startTime = task.startTime || new Date().toISOString();
                task.endTime = null;

				// --- ここから自動移動ロジック ---
	            const currentSection = getCurrentSection();
	            const targetSectionId = currentSection ? currentSection.id : null;
	
	            // セクションが変更される場合のみ移動処理を行う
	            if (task.sectionId !== targetSectionId) {
	                task.sectionId = targetSectionId;
	
	                // タスクを一度リストから取り出す
	                const taskIndex = tasks.findIndex(t => t.id === id);
	                if (taskIndex > -1) tasks.splice(taskIndex, 1);
	
	                // 移動先のセクションで、未完了タスクの最初の位置を探す
	                let insertIndex = tasks.length;
	                const firstUncompletedIndexInSection = tasks.findIndex(t => 
	                    (t.sectionId === targetSectionId) && (getTaskStatus(t) !== 'completed')
	                );
	
	                if (firstUncompletedIndexInSection > -1) {
	                    insertIndex = firstUncompletedIndexInSection;
	                } else {
	                    // 未完了タスクがない場合、セクションの末尾を探す
	                    let lastIndexOfSection = -1;
	                    for(let i = tasks.length - 1; i >= 0; i--) {
	                        if (tasks[i].sectionId === targetSectionId) {
	                            lastIndexOfSection = i;
	                            break;
	                        }
	                    }
	                    insertIndex = lastIndexOfSection > -1 ? lastIndexOfSection + 1 : tasks.length;
	                }
	                tasks.splice(insertIndex, 0, task);
	            }
			
                updateTaskStatus(task);
                state.activeTaskId = id;
                state.focusedTaskId = id;
                task.updatedAt = new Date().toISOString();
                
                state.activeTimerId = setInterval(() => {
                    const timeEl = document.querySelector(`[data-task-id="${id}"] .time-actual`);
                    if (timeEl) {
                        timeEl.textContent = formatTime(calculateActualTime(task));
                    }
					const floatingTimeEl = document.getElementById('floating-elapsed-time');
				    if (floatingTimeEl) {
				        floatingTimeEl.textContent = formatTime(currentActualTime);
				    }
                }, 1000);
            }
        }
        saveAndRender();
    }

    function stopActiveTimer() {
        clearInterval(state.activeTimerId);
        state.activeTimerId = null;
        state.activeTaskId = null;
    }

    function addRepeatTask() {
        const name = document.getElementById('repeat-task-name').value.trim();
        const time = parseInt(document.getElementById('repeat-task-time').value, 10);
        const projectId = document.getElementById('repeat-task-project').value || null;
		const sectionId = document.getElementById('repeat-task-section').value || null;
        const type = document.getElementById('repeat-task-type').value;

        if (!name || isNaN(time) || time < 0) return alert('タスク名と見積時間を正しく入力してください。');

        let value = null;
        let startDate = null;
        let weekInterval = 1;

        if (type === 'weekly') {
            value = Array.from(document.querySelectorAll('#repeat-weekly-days input:checked')).map(cb => parseInt(cb.value, 10));
            if (value.length === 0) return alert('曜日を選択してください。');
            weekInterval = parseInt(document.getElementById('repeat-weekly-interval').value, 10) || 1;
            startDate = document.getElementById('repeat-weekly-start-date').value || new Date().toISOString().slice(0,10);
        } else if (type === 'monthly') {
            const monthlyType = document.querySelector('input[name="repeat-monthly-type"]:checked').value;
            if (monthlyType === 'day') {
                const day = parseInt(document.getElementById('repeat-monthly-day').value, 10);
                if (isNaN(day) || day < 1 || day > 31) { return alert('有効な日付を入力してください。'); }
                value = { type: 'day', day: day };
            } else {
                const week = parseInt(document.getElementById('repeat-monthly-week').value, 10);
                const weekday = parseInt(document.getElementById('repeat-monthly-weekday').value, 10);
                value = { type: 'weekday', week: week, weekday: weekday };
            }
        } else if (type === 'yearly') {
            const month = parseInt(document.getElementById('repeat-yearly-month').value, 10);
            const day = parseInt(document.getElementById('repeat-yearly-day').value, 10);
            if (isNaN(month) || month < 1 || month > 12 || isNaN(day) || day < 1 || day > 31) {
                return alert('有効な月日を入力してください。');
            }
            value = { month, day };
        } else if (type === 'interval') {
            value = parseInt(document.getElementById('repeat-interval-days').value, 10);
            if (isNaN(value) || value < 1) return alert('有効な間隔（日数）を入力してください。');
            startDate = document.getElementById('repeat-interval-start-date').value || new Date().toISOString().slice(0,10);
        }

        state.repeatTasks.push({ id: 'rt' + Date.now(), name, estimatedTime: time, projectId, sectionId, memo, type, value, startDate, weekInterval, subtasks: [] });

        // --- 入力フォームのリセット ---
        document.getElementById('repeat-task-name').value = '';
        document.getElementById('repeat-task-time').value = '';
        document.querySelectorAll('#repeat-weekly-days input').forEach(cb => cb.checked = false);
        document.getElementById('repeat-weekly-interval').value = '1';
        document.getElementById('repeat-monthly-day').value = '';
        document.getElementById('repeat-yearly-month').value = '';
        document.getElementById('repeat-yearly-day').value = '';
        document.getElementById('repeat-interval-days').value = '';
        document.getElementById('repeat-interval-start-date').value = '';
        document.getElementById('repeat-weekly-start-date').value = '';
        saveAndRender();
    }

    function deleteRepeatTask(id) {
        const repeatTask = state.repeatTasks.find(rt => rt.id === id);
        if (!repeatTask) return;
        if (!confirm(`リピートタスク「${repeatTask.name}」を削除しますか？`)) return;
        state.repeatTasks = state.repeatTasks.filter(rt => rt.id !== id);
        saveAndRender();
    }

    function addProject() {
        const name = document.getElementById('project-name').value.trim();
        const color = document.getElementById('project-color').value;
        if (!name) { alert('プロジェクト名を入力してください。'); return; }
        state.projects.push({ id: 'p' + Date.now(), name, color });
        document.getElementById('project-name').value = '';
        saveAndRender();
    }

    function editProject(id) {
        const project = state.projects.find(p => p.id === id);
        if(!project) return;
        const newName = prompt('新しいプロジェクト名を入力してください:', project.name);
        if(newName && newName.trim()) {
            project.name = newName.trim();
        }
        const newColor = prompt('新しいカラーコード（例: #ff0000）を入力してください:', project.color);
        if(newColor && /^#[0-9A-Fa-f]{6}$/.test(newColor)) {
            project.color = newColor;
        }
        saveAndRender();
    }

    function deleteProject(id) {
        const project = state.projects.find(p => p.id === id);
        if (!project) return;
        if (!confirm(`プロジェクト「${project.name}」を削除しますか？関連するタスクからプロジェクト設定が解除されます。`)) return;
        state.projects = state.projects.filter(p => p.id !== id);
        Object.values(state.dailyTasks).flat().forEach(t => { if(t.projectId === id) t.projectId = null; });
        state.repeatTasks.forEach(rt => { if(rt.projectId === id) rt.projectId = null; });
        saveAndRender();
    }

	function exportData() {
	    const exportData = {
	        dailyTasks: state.dailyTasks,
	        projects: state.projects,
	        repeatTasks: state.repeatTasks,
	        sections: state.sections,
	        archivedTasks: state.archivedTasks,
	        lastDate: state.lastDate,
	        exportDate: new Date().toISOString()
	    };
	
	    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
	    const url = URL.createObjectURL(blob);
	    const a = document.createElement('a');
	    a.href = url;
	    a.download = `dtl_export_${new Date().toISOString().slice(0, 10)}.json`;
	    a.click();
	    URL.revokeObjectURL(url);
	    
	    alert('データをエクスポートしました。');
	}

	function importData() {
	    const fileInput = document.getElementById('import-file');
	    const file = fileInput.files[0];
	    if (!file) return alert('インポートするファイルを選択してください。');
	    
	    if (!confirm('データをインポートします。IDが重複するデータは上書きされます。よろしいですか?')) return;
	
	    const reader = new FileReader();
	    reader.onload = (e) => {
	        try {
	            const importedData = JSON.parse(e.target.result);
	            
	            // --- セクション情報の復元 ---
	            if (importedData.sections && Array.isArray(importedData.sections)) {
	                const sectionMap = new Map(state.sections.map(s => [s.id, s]));
	                importedData.sections.forEach(s => sectionMap.set(s.id, s));
	                state.sections = Array.from(sectionMap.values());
	                // セクションを開始時刻でソート
	                state.sections.sort((a, b) => a.startTime.localeCompare(b.startTime));
	            }
	            
	            Object.assign(state.dailyTasks, importedData.dailyTasks || {});
	            Object.assign(state.archivedTasks, importedData.archivedTasks || {});
	
	            if (importedData.projects && Array.isArray(importedData.projects)) {
	                const projectMap = new Map(state.projects.map(p => [p.id, p]));
	                importedData.projects.forEach(p => projectMap.set(p.id, p));
	                state.projects = Array.from(projectMap.values());
	            }
	            
	            if (importedData.repeatTasks && Array.isArray(importedData.repeatTasks)) {
	                const repeatTaskMap = new Map(state.repeatTasks.map(rt => [rt.id, rt]));
	                importedData.repeatTasks.forEach(rt => repeatTaskMap.set(rt.id, rt));
	                state.repeatTasks = Array.from(repeatTaskMap.values());
	            }
	
	            state.lastDate = importedData.lastDate || state.lastDate;
	            
	            stopActiveTimer();
	            state.viewDate = getFormattedDate(new Date());
	            const tasksToday = getTasksForViewDate();
	
	            const firstUncompletedTask = tasksToday.find(t => getTaskStatus(t) !== 'completed');
	            if (firstUncompletedTask) {
	                // 未完了タスクがあれば、その最初のタスクを選択
	                state.focusedTaskId = firstUncompletedTask.id;
	            } else if (tasksToday.length > 0) {
	                // 未完了タスクがなく、タスクが1件以上あれば、リストの最後のタスクを選択
	                state.focusedTaskId = tasksToday[tasksToday.length - 1].id;
	            } else {
	                // タスクがなければ選択しない
	                state.focusedTaskId = null;
	            }
	        
	            Object.values(state.dailyTasks).flat().forEach(task => updateTaskStatus(task));
	            
	            saveAndRender();
	            alert('データをインポートしました。');
	            fileInput.value = '';
	        } catch (error) {
	            alert('無効なファイル形式です。正しいJSONファイルを選択してください。');
	            console.error('Import error:', error);
	        }
	    };
	    reader.readAsText(file);
	}

    function clearAllData() {
        if (!confirm('本当に全てのデータを削除しますか？この操作は元に戻せません。')) return;
        if (!confirm('最終確認！全てのタスク、プロジェクト、履歴データが削除されます。')) return;
        
        Object.keys(localStorage).forEach(key => {
            if (key.startsWith('dtl_')) localStorage.removeItem(key);
        });
        
        location.reload();
    }

    function calculateAllEstimates() {
        const now = new Date();
        const unfinishedTasks = getTasksForViewDate().filter(t => t.status !== 'completed');
        const totalRemainingMinutes = unfinishedTasks.reduce((sum, task) => sum + (task.estimatedTime || 0), 0);
        totalEstimatedEndTimeEl.textContent = totalRemainingMinutes > 0 ? formatClockTime(new Date(now.getTime() + totalRemainingMinutes * 60 * 1000)) : '完了';
    }

	function renderFloatingTaskBar() {
	    const bar = document.getElementById('floating-task-bar');
	    const barContent = document.getElementById('floating-task-bar-content'); 
	    if (!bar || !barContent) return;

	    // スマホ以外、またはモーダル表示中はバーを隠す
	    if (!isMobile() || document.querySelector('.modal.active')) {
	        bar.classList.remove('active');
	        return;
	    }

	    const tasks = getTasksForViewDate();
	    const activeTask = tasks.find(t => t.id === state.activeTaskId);
	    const nextTask = tasks.find(t => getTaskStatus(t) !== 'completed');
	    const taskToDisplay = activeTask || nextTask;

		const addTaskButtonHtml = `
            <button id="add-task-btn-bar" class="floating-bar-btn bg-blue-600 hover:bg-blue-700 text-white text-3xl font-bold">
                ＋
            </button>`;

	    if (!taskToDisplay) {
			// 表示するタスクがない場合でも、バーと追加ボタンは表示する
			barContent.innerHTML = `
				<div class="flex-1 px-3 min-w-0 flex items-center">
					<p class="text-gray-500">全てのタスクが完了しました 🎉</p>
				</div>
				${addTaskButtonHtml}
			`;
			bar.classList.add('active'); // activeクラスは外側のバーに設定
			barContent.querySelector('#add-task-btn-bar').addEventListener('click', openAddTaskModal);
			return;
        }

        const isTaskRunning = !!activeTask;
        const buttonIcon = isTaskRunning ? '■' : '▶';
        const buttonColor = isTaskRunning ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600';

        let taskInfoHtml = '';
        if (isTaskRunning) {
            const estimatedEndTime = new Date(new Date(activeTask.startTime).getTime() + (activeTask.estimatedTime * 60 * 1000));
            taskInfoHtml = `
                <p class="text-base font-bold text-gray-800 truncate" title="${escapeHtml(activeTask.name)}">${formatTaskName(activeTask.name)}</p>
	            <p class="text-gray-500 font-mono">終了予定: ${formatClockTime(estimatedEndTime)}</p>
            `;
        } else {
            taskInfoHtml = `
                <p class="text-gray-500">Next: <span class="font-bold text-gray-800 truncate" title="${escapeHtml(nextTask.name)}">${formatTaskName(nextTask.name)}</span></p>
	            <p class="text-sm text-gray-500">${nextTask.estimatedTime || 0}分</p>
            `;
        }

        const timerButtonHtml = `
            <button id="floating-timer-btn" class="floating-bar-btn ${buttonColor} text-white text-2xl">
                ${buttonIcon}
            </button>`;

		barContent.innerHTML = `
		    ${timerButtonHtml}
		    <div class="flex-1 px-3 min-w-0 cursor-pointer" 
		         id="floating-task-info"
		         data-task-id="${taskToDisplay.id}">
		        ${taskInfoHtml}
		    </div>
		    ${addTaskButtonHtml}
		`;
		
		// タップイベントのハンドリング
		const taskInfoArea = barContent.querySelector('#floating-task-info');
		if (taskInfoArea) {
		    let clickTimer = null;
		    const delay = 250; // ダブルタップの待機時間 (ミリ秒)
		
		    taskInfoArea.addEventListener('click', (e) => {
		        // リンクがクリックされた場合は、デフォルトの動作（ページ遷移）を許可
		        if (e.target.tagName === 'A' || e.target.closest('a')) {
		            // リンクの場合は何もしない（デフォルト動作を許可）
		            return;
		        }
		        
		        e.preventDefault();
		        // ダブルタップでないことを確認するため、タイマーを設定
		        if (clickTimer === null) {
		            clickTimer = setTimeout(() => {
		                clickTimer = null;
		                // タイマーが実行されたらシングルタップと判断し、スクロール処理を実行
		                const taskElement = document.querySelector(`[data-task-id='${taskToDisplay.id}']`);
		                if (taskElement) {
		                    taskElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
		                }
		            }, delay);
		        }
		    });
		
		    taskInfoArea.addEventListener('dblclick', (e) => {
		        // リンクがダブルクリックされた場合も、デフォルトの動作を許可
		        if (e.target.tagName === 'A' || e.target.closest('a')) {
		            return;
		        }
		        
		        e.preventDefault();
		        // シングルタップ用のタイマーが設定されていれば、それを解除
		        if (clickTimer) {
		            clearTimeout(clickTimer);
		            clickTimer = null;
		        }
		        // ダブルタップの処理（メモ編集モーダル表示）を実行
		        openMemoEditModal(taskToDisplay.id);
		    });
		}

	    bar.classList.add('active'); // activeクラスは外側のバーに設定
        barContent.querySelector('#floating-timer-btn').addEventListener('click', () => toggleTimer(taskToDisplay.id));
        barContent.querySelector('#add-task-btn-bar').addEventListener('click', openAddTaskModal);
	}

    function handleKeyboardShortcuts(e) {
        if (document.querySelector('input:focus, select:focus, textarea:focus, .modal.active')) return;
        
        const activeTab = document.querySelector('.tab-link.active').dataset.tab;

        if (activeTab === 'today') {
            handleTodayShortcuts(e);
        } else if (activeTab === 'archive') {
            handleArchiveShortcuts(e);
        }
    }

	function handleTodayShortcuts(e) {
        const tasks = getTasksForViewDate();
        if (tasks.length === 0 && !['n', 'r', 'arrowleft', 'arrowright'].includes(e.key.toLowerCase())) return;

        const currentTaskIndex = tasks.findIndex(t => t.id === state.focusedTaskId);
        const currentTask = (currentTaskIndex !== -1) ? tasks[currentTaskIndex] : null;

        // --- サブタスクがフォーカスされている場合の処理 ---
        if (currentTask && state.focusedSubtaskId) {
            const subtasks = currentTask.subtasks || [];
            const currentSubtaskIndex = subtasks.findIndex(st => st.id === state.focusedSubtaskId);

            if (currentSubtaskIndex !== -1) {
                switch (e.key.toLowerCase()) {
                    case 'arrowup':
                    case 'arrowdown':
                        e.preventDefault();
                        if (e.ctrlKey || e.metaKey) {
                            // 変更点: サブタスク選択中の親タスク移動は、新しいロジックに任せる
                            // そのため、ここでは何もしないで下の処理に流す
                        } else { // 選択移動
                             if (e.key === 'arrowup') {
                                if (currentSubtaskIndex > 0) {
                                    state.focusedSubtaskId = subtasks[currentSubtaskIndex - 1].id;
                                } else {
                                    state.focusedSubtaskId = null; // 親タスクに戻る
                                }
                            } else { // arrowdown
                                if (currentSubtaskIndex < subtasks.length - 1) {
                                    state.focusedSubtaskId = subtasks[currentSubtaskIndex + 1].id;
                                } else { // 最後のサブタスクから次のタスクへ
                                    state.focusedSubtaskId = null;
                                    if (currentTaskIndex < tasks.length - 1) {
                                        state.focusedTaskId = tasks[currentTaskIndex + 1].id;
                                    }
                                }
                            }
                            render();
                            return; // ここで処理を終了
                        }
                        break; // breakを追加
                    case ' ':
                        e.preventDefault();
                        const subtask = subtasks[currentSubtaskIndex];
                        toggleSubtaskCompletion(currentTask.id, subtask.id, !subtask.completed);
                        return;
                }
            }
        }
        
        // --- 親タスクがフォーカスされている場合の処理、またはCtrlキー押下時のサブタスクからの処理 ---
        switch (e.key.toLowerCase()) {
            case 'n': e.preventDefault(); openAddTaskModal(); break;
            case 'e': e.preventDefault(); if (state.focusedTaskId) openTaskEditModal(state.focusedTaskId); break;
            case 'm': e.preventDefault(); if (state.focusedTaskId) openMemoEditModal(state.focusedTaskId); break;
            case 'd': e.preventDefault(); if (state.focusedTaskId) deleteTask(state.focusedTaskId); break;
            case 'p': e.preventDefault(); if (state.focusedTaskId) postponeTask(state.focusedTaskId); break;
            case 's': e.preventDefault(); if (state.focusedTaskId) toggleSubtaskView(state.focusedTaskId); break;
            case 'r':
                e.preventDefault();
                if (dailyTaskListApp.dbx) {
                    dailyTaskListApp.loadStateFromDropbox();
                }
                break;
            case 'arrowdown':
            case 'arrowup':
                e.preventDefault();
                if (!currentTask) {
                    if (tasks.length > 0) state.focusedTaskId = tasks[0].id;
                    render();
                    break;
                }

                if (e.ctrlKey || e.metaKey) {
                    // --- 変更点: 新しいタスク移動ロジック ---
                    const direction = e.key.toLowerCase() === 'arrowdown' ? 1 : -1;
                    const movedTask = tasks.splice(currentTaskIndex, 1)[0];
                    let newIndex = currentTaskIndex;

                    const sortedSections = [...state.sections].sort((a, b) => a.startTime.localeCompare(b.startTime));
                    const sectionOrder = ['null', ...sortedSections.map(s => s.id)];
                    const currentSectionId = movedTask.sectionId || 'null';
                    
                    // 同じセクション内のタスクを取得
                    const tasksInCurrentSection = tasks.filter(t => (t.sectionId || 'null') === currentSectionId);
                    const taskIndexWithinSection = tasksInCurrentSection.findIndex(t => t.id === movedTask.id); // splice前なので見つからないが、これは元の位置を把握するため
                    const originalTaskIndexWithinSection = getTasksForViewDate().filter(t => (t.id !== movedTask.id) && ((t.sectionId || 'null') === currentSectionId)).findIndex(t=>t.id === state.focusedTaskId)

                    const isAtBoundary = (direction === 1 && (currentTaskIndex === tasks.length || (tasks[currentTaskIndex].sectionId || 'null') !== currentSectionId)) ||
                                         (direction === -1 && (currentTaskIndex === 0 || (tasks[currentTaskIndex-1].sectionId || 'null') !== currentSectionId));

                    if (!isAtBoundary) {
                        // セクション内での移動
                        newIndex = currentTaskIndex + direction;
                    } else {
                        // セクション境界を越える移動
                        const currentSectionOrderIndex = sectionOrder.indexOf(currentSectionId);
                        let nextSectionOrderIndex = currentSectionOrderIndex + direction;
                        if (nextSectionOrderIndex >= 0 && nextSectionOrderIndex < sectionOrder.length) {
                            const nextSectionId = sectionOrder[nextSectionOrderIndex];
                            movedTask.sectionId = nextSectionId === 'null' ? null : nextSectionId;
                            
                            if (direction === 1) { // 下へ移動
                                // 次のセクションの最初のタスクを探す
                                const firstTaskOfNextSectionIndex = tasks.findIndex(t => (t.sectionId || 'null') === nextSectionId);
                                if (firstTaskOfNextSectionIndex !== -1) {
                                    newIndex = firstTaskOfNextSectionIndex;
                                } else {
                                    // 次のセクションが空の場合、さらにその次のセクションの開始位置を探す
                                    let followingSectionFound = false;
                                    for(let i = nextSectionOrderIndex + 1; i < sectionOrder.length; i++) {
                                        const followingSectionId = sectionOrder[i];
                                        const firstTaskIndex = tasks.findIndex(t => (t.sectionId || 'null') === followingSectionId);
                                        if (firstTaskIndex !== -1) {
                                            newIndex = firstTaskIndex;
                                            followingSectionFound = true;
                                            break;
                                        }
                                    }
                                    if (!followingSectionFound) newIndex = tasks.length;
                                }
                            } else { // 上へ移動
                                // 前のセクションの最後のタスクを探す
                                let lastTaskOfPrevSectionIndex = -1;
                                for(let i = tasks.length - 1; i >= 0; i--) {
                                    if ((tasks[i].sectionId || 'null') === nextSectionId) {
                                        lastTaskOfPrevSectionIndex = i;
                                        break;
                                    }
                                }
                                if (lastTaskOfPrevSectionIndex !== -1) {
                                    newIndex = lastTaskOfPrevSectionIndex + 1;
                                } else {
                                     // 前のセクションが空の場合、そのセクションの開始位置を探す
                                     let precedingSectionFound = false;
                                     for(let i = nextSectionOrderIndex + 1; i < sectionOrder.length; i++) {
                                        const followingSectionId = sectionOrder[i];
                                        const firstTaskIndex = tasks.findIndex(t => (t.sectionId || 'null') === followingSectionId);
                                        if (firstTaskIndex !== -1) {
                                            newIndex = firstTaskIndex;
                                            precedingSectionFound = true;
                                            break;
                                        }
                                     }
                                     if (!precedingSectionFound) newIndex = tasks.length;
                                }
                            }
                        } else {
                            // リストの端に到達した場合
                             newIndex = (direction === 1) ? tasks.length : 0;
                        }
                    }

                    tasks.splice(newIndex, 0, movedTask);
                    setTasksForViewDate(tasks);
                    saveAndRender();

                } else { // --- 通常の選択移動 ---
                     const direction = e.key.toLowerCase() === 'arrowdown' ? 1 : -1;
                    if (direction === 1) {
                        const hasOpenSubtasks = state.openTaskIds.has(currentTask.id) && currentTask.subtasks && currentTask.subtasks.length > 0;
                        if (hasOpenSubtasks) {
                            state.focusedSubtaskId = currentTask.subtasks[0].id;
                        } else if (currentTaskIndex < tasks.length - 1) {
                            state.focusedTaskId = tasks[currentTaskIndex + 1].id;
                        }
                    } else { // direction === -1 (up)
                        if (currentTaskIndex > 0) {
                            const prevTask = tasks[currentTaskIndex - 1];
                            const prevHasOpenSubtasks = state.openTaskIds.has(prevTask.id) && prevTask.subtasks && prevTask.subtasks.length > 0;
                            if (prevHasOpenSubtasks) {
                                state.focusedTaskId = prevTask.id;
                                state.focusedSubtaskId = prevTask.subtasks[prevTask.subtasks.length - 1].id;
                            } else {
                                state.focusedTaskId = prevTask.id;
                            }
                        }
                    }
                    render();
                }
                break;
            case 'arrowleft': e.preventDefault(); moveViewDate(-1); break;
            case 'arrowright': e.preventDefault(); moveViewDate(1); break;
            case ' ': e.preventDefault(); if (state.focusedTaskId && !state.focusedSubtaskId) toggleTimer(state.focusedTaskId); break;
        }
    }

    function handleArchiveShortcuts(e) {
        switch(e.key) {
            case 'ArrowLeft': e.preventDefault(); if (state.archiveView === 'date') moveArchiveDate(-1); break;
            case 'ArrowRight': e.preventDefault(); if (state.archiveView === 'date') moveArchiveDate(1); break;
        }
    }
    
    function moveViewDate(direction) {
        const todayStr = getFormattedDate(new Date());
        const limitDate = new Date();
        limitDate.setDate(limitDate.getDate() + 2);
        const limitDateStr = getFormattedDate(limitDate);

        if (direction === 1 && state.viewDate >= limitDateStr) {
            return; // 2日後より先には進めない
        }
        if (direction === -1 && state.viewDate <= todayStr) {
            return;
        }
        const currentDate = new Date(state.viewDate);
        currentDate.setDate(currentDate.getDate() + direction);
        state.viewDate = getFormattedDate(currentDate);
        const tasks = getTasksForViewDate();
        const firstUncompletedTask = tasks.find(t => getTaskStatus(t) !== 'completed');
        if (firstUncompletedTask) {
            // 未完了タスクがあれば、その最初のタスクを選択
            state.focusedTaskId = firstUncompletedTask.id;
        } else if (tasks.length > 0) {
            // 未完了タスクがなく、タスクが1件以上あれば、リストの最後のタスクを選択
            state.focusedTaskId = tasks[tasks.length - 1].id;
        } else {
            // タスクがなければ選択しない
            state.focusedTaskId = null;
        }
        renderTodayTasks();
    }
    
    function moveArchiveDate(direction) {
        const currentDate = new Date(state.archiveViewDate);
        currentDate.setDate(currentDate.getDate() + direction);
        state.archiveViewDate = getFormattedDate(currentDate);
        renderArchive();
    }

    function escapeHtml(s) {
        if (!s) return '';
        return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }

    function formatTaskName(text) {
        if (!text) return '';
        let escapedText = escapeHtml(text);
        const markdownRegex = /\[(.*?)\]\((.*?)\)/g;
        escapedText = escapedText.replace(markdownRegex, (match, linkText, url) => {
            const safeUrl = url.replace(/&amp;/g, '&');
             return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">${linkText}</a>`;
        });
        const urlRegex = /([a-zA-Z][a-zA-Z0-9+.-]*:\/\/\S+)/g;
        const parts = escapedText.split(/(<[^>]+>)/);
        return parts.map(part => {
             if (part.startsWith('<')) return part;
             return part.replace(urlRegex, url => {
                const safeUrl = url.replace(/&amp;/g, '&');
                return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">${url}</a>`;
            });
        }).join('');
    }
    
    function calculateActualTime(task) {
        if (task.status === 'running' && task.startTime) {
             return Math.round((new Date().getTime() - new Date(task.startTime).getTime()) / 1000);
        }
        if (task.startTime && task.endTime) {
            const duration = new Date(task.endTime).getTime() - new Date(task.startTime).getTime();
            return Math.round(Math.max(0, duration) / 1000);
        }
        return task.actualTime || 0;
    }

    function saveAndRender(options = {}) { updateSortOrderAndTimestamps(state.viewDate); saveState(); render(options); updateTitle(); }
    function updateTimeDisplays() {
        currentDateEl.textContent = new Date().toLocaleString('ja-JP', { year:'numeric', month:'long', day:'numeric', weekday:'long' });
        calculateAllEstimates();
    }
	function formatTime(seconds) {
        const s = parseInt(seconds, 10) || 0;
        const m = Math.floor(s / 60);
        const sec = (s % 60).toString().padStart(2,'0');
        return `${m.toString().padStart(2, '0')}:${sec}`;
    }
    function formatClockTime(date) {
        if (!date) return '--:--';
        return date.toLocaleTimeString('ja-JP', { hour:'2-digit', minute:'2-digit' });
    }

    function renderPcAddTaskButton() {
        const container = document.getElementById('add-task-floating-container');
        if (!container) return;

        container.innerHTML = `
            <button id="add-task-btn-floating" class="fab bg-blue-600 hover:bg-blue-700 text-white text-3xl font-bold">
                ＋
            </button>`;
        
        container.querySelector('#add-task-btn-floating').addEventListener('click', openAddTaskModal);
    }

    init();
});
</script>
	
</body>
</html>
